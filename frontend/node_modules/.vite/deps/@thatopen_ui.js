import "./chunk-ZS7NZCD4.js";

// node_modules/@thatopen/ui/dist/index.js
var Ns = Object.defineProperty;
var Ds = (i, t, e) => t in i ? Ns(i, t, { enumerable: true, configurable: true, writable: true, value: e }) : i[t] = e;
var ot = (i, t, e) => (Ds(i, typeof t != "symbol" ? t + "" : t, e), e);
var It = Math.min;
var K = Math.max;
var we = Math.round;
var ct = (i) => ({
  x: i,
  y: i
});
var Fs = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var Vs = {
  start: "end",
  end: "start"
};
function Zi(i, t, e) {
  return K(i, It(t, e));
}
function ae(i, t) {
  return typeof i == "function" ? i(t) : i;
}
function X(i) {
  return i.split("-")[0];
}
function Me(i) {
  return i.split("-")[1];
}
function jn(i) {
  return i === "x" ? "y" : "x";
}
function Bn(i) {
  return i === "y" ? "height" : "width";
}
function Ct(i) {
  return ["top", "bottom"].includes(X(i)) ? "y" : "x";
}
function Hn(i) {
  return jn(Ct(i));
}
function Us(i, t, e) {
  e === void 0 && (e = false);
  const s = Me(i), n = Hn(i), r = Bn(n);
  let o = n === "x" ? s === (e ? "end" : "start") ? "right" : "left" : s === "start" ? "bottom" : "top";
  return t.reference[r] > t.floating[r] && (o = $e(o)), [o, $e(o)];
}
function qs(i) {
  const t = $e(i);
  return [ei(i), t, ei(t)];
}
function ei(i) {
  return i.replace(/start|end/g, (t) => Vs[t]);
}
function Ws(i, t, e) {
  const s = ["left", "right"], n = ["right", "left"], r = ["top", "bottom"], o = ["bottom", "top"];
  switch (i) {
    case "top":
    case "bottom":
      return e ? t ? n : s : t ? s : n;
    case "left":
    case "right":
      return t ? r : o;
    default:
      return [];
  }
}
function Qs(i, t, e, s) {
  const n = Me(i);
  let r = Ws(X(i), e === "start", s);
  return n && (r = r.map((o) => o + "-" + n), t && (r = r.concat(r.map(ei)))), r;
}
function $e(i) {
  return i.replace(/left|right|bottom|top/g, (t) => Fs[t]);
}
function Ys(i) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...i
  };
}
function Nn(i) {
  return typeof i != "number" ? Ys(i) : {
    top: i,
    right: i,
    bottom: i,
    left: i
  };
}
function Rt(i) {
  const {
    x: t,
    y: e,
    width: s,
    height: n
  } = i;
  return {
    width: s,
    height: n,
    top: e,
    left: t,
    right: t + s,
    bottom: e + n,
    x: t,
    y: e
  };
}
function tn(i, t, e) {
  let {
    reference: s,
    floating: n
  } = i;
  const r = Ct(t), o = Hn(t), a = Bn(o), l = X(t), c = r === "y", u = s.x + s.width / 2 - n.width / 2, d = s.y + s.height / 2 - n.height / 2, f = s[a] / 2 - n[a] / 2;
  let p;
  switch (l) {
    case "top":
      p = {
        x: u,
        y: s.y - n.height
      };
      break;
    case "bottom":
      p = {
        x: u,
        y: s.y + s.height
      };
      break;
    case "right":
      p = {
        x: s.x + s.width,
        y: d
      };
      break;
    case "left":
      p = {
        x: s.x - n.width,
        y: d
      };
      break;
    default:
      p = {
        x: s.x,
        y: s.y
      };
  }
  switch (Me(t)) {
    case "start":
      p[o] -= f * (e && c ? -1 : 1);
      break;
    case "end":
      p[o] += f * (e && c ? -1 : 1);
      break;
  }
  return p;
}
var Gs = async (i, t, e) => {
  const {
    placement: s = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o
  } = e, a = r.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: i,
    floating: t,
    strategy: n
  }), {
    x: u,
    y: d
  } = tn(c, s, l), f = s, p = {}, b = 0;
  for (let v = 0; v < a.length; v++) {
    const {
      name: g,
      fn: S
    } = a[v], {
      x: E,
      y: x,
      data: $,
      reset: O
    } = await S({
      x: u,
      y: d,
      initialPlacement: s,
      placement: f,
      strategy: n,
      middlewareData: p,
      rects: c,
      platform: o,
      elements: {
        reference: i,
        floating: t
      }
    });
    u = E ?? u, d = x ?? d, p = {
      ...p,
      [g]: {
        ...p[g],
        ...$
      }
    }, O && b <= 50 && (b++, typeof O == "object" && (O.placement && (f = O.placement), O.rects && (c = O.rects === true ? await o.getElementRects({
      reference: i,
      floating: t,
      strategy: n
    }) : O.rects), {
      x: u,
      y: d
    } = tn(c, f, l)), v = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: n,
    middlewareData: p
  };
};
async function Dn(i, t) {
  var e;
  t === void 0 && (t = {});
  const {
    x: s,
    y: n,
    platform: r,
    rects: o,
    elements: a,
    strategy: l
  } = i, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = false,
    padding: p = 0
  } = ae(t, i), b = Nn(p), g = a[f ? d === "floating" ? "reference" : "floating" : d], S = Rt(await r.getClippingRect({
    element: (e = await (r.isElement == null ? void 0 : r.isElement(g))) == null || e ? g : g.contextElement || await (r.getDocumentElement == null ? void 0 : r.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), E = d === "floating" ? {
    x: s,
    y: n,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, x = await (r.getOffsetParent == null ? void 0 : r.getOffsetParent(a.floating)), $ = await (r.isElement == null ? void 0 : r.isElement(x)) ? await (r.getScale == null ? void 0 : r.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = Rt(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: E,
    offsetParent: x,
    strategy: l
  }) : E);
  return {
    top: (S.top - O.top + b.top) / $.y,
    bottom: (O.bottom - S.bottom + b.bottom) / $.y,
    left: (S.left - O.left + b.left) / $.x,
    right: (O.right - S.right + b.right) / $.x
  };
}
var Ks = function(i) {
  return i === void 0 && (i = {}), {
    name: "flip",
    options: i,
    async fn(t) {
      var e, s;
      const {
        placement: n,
        middlewareData: r,
        rects: o,
        initialPlacement: a,
        platform: l,
        elements: c
      } = t, {
        mainAxis: u = true,
        crossAxis: d = true,
        fallbackPlacements: f,
        fallbackStrategy: p = "bestFit",
        fallbackAxisSideDirection: b = "none",
        flipAlignment: v = true,
        ...g
      } = ae(i, t);
      if ((e = r.arrow) != null && e.alignmentOffset)
        return {};
      const S = X(n), E = Ct(a), x = X(a) === a, $ = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), O = f || (x || !v ? [$e(a)] : qs(a)), _ = b !== "none";
      !f && _ && O.push(...Qs(a, v, b, $));
      const L = [a, ...O], D = await Dn(t, g), F = [];
      let A = ((s = r.flip) == null ? void 0 : s.overflows) || [];
      if (u && F.push(D[S]), d) {
        const W = Us(n, o, $);
        F.push(D[W[0]], D[W[1]]);
      }
      if (A = [...A, {
        placement: n,
        overflows: F
      }], !F.every((W) => W <= 0)) {
        var Ot, Wt;
        const W = (((Ot = r.flip) == null ? void 0 : Ot.index) || 0) + 1, Pt = L[W];
        if (Pt)
          return {
            data: {
              index: W,
              overflows: A
            },
            reset: {
              placement: Pt
            }
          };
        let nt = (Wt = A.filter((st) => st.overflows[0] <= 0).sort((st, Q) => st.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : Wt.placement;
        if (!nt)
          switch (p) {
            case "bestFit": {
              var kt;
              const st = (kt = A.filter((Q) => {
                if (_) {
                  const rt = Ct(Q.placement);
                  return rt === E || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  rt === "y";
                }
                return true;
              }).map((Q) => [Q.placement, Q.overflows.filter((rt) => rt > 0).reduce((rt, Hs) => rt + Hs, 0)]).sort((Q, rt) => Q[1] - rt[1])[0]) == null ? void 0 : kt[0];
              st && (nt = st);
              break;
            }
            case "initialPlacement":
              nt = a;
              break;
          }
        if (n !== nt)
          return {
            reset: {
              placement: nt
            }
          };
      }
      return {};
    }
  };
};
function Fn(i) {
  const t = It(...i.map((r) => r.left)), e = It(...i.map((r) => r.top)), s = K(...i.map((r) => r.right)), n = K(...i.map((r) => r.bottom));
  return {
    x: t,
    y: e,
    width: s - t,
    height: n - e
  };
}
function Xs(i) {
  const t = i.slice().sort((n, r) => n.y - r.y), e = [];
  let s = null;
  for (let n = 0; n < t.length; n++) {
    const r = t[n];
    !s || r.y - s.y > s.height / 2 ? e.push([r]) : e[e.length - 1].push(r), s = r;
  }
  return e.map((n) => Rt(Fn(n)));
}
var Js = function(i) {
  return i === void 0 && (i = {}), {
    name: "inline",
    options: i,
    async fn(t) {
      const {
        placement: e,
        elements: s,
        rects: n,
        platform: r,
        strategy: o
      } = t, {
        padding: a = 2,
        x: l,
        y: c
      } = ae(i, t), u = Array.from(await (r.getClientRects == null ? void 0 : r.getClientRects(s.reference)) || []), d = Xs(u), f = Rt(Fn(u)), p = Nn(a);
      function b() {
        if (d.length === 2 && d[0].left > d[1].right && l != null && c != null)
          return d.find((g) => l > g.left - p.left && l < g.right + p.right && c > g.top - p.top && c < g.bottom + p.bottom) || f;
        if (d.length >= 2) {
          if (Ct(e) === "y") {
            const A = d[0], Ot = d[d.length - 1], Wt = X(e) === "top", kt = A.top, W = Ot.bottom, Pt = Wt ? A.left : Ot.left, nt = Wt ? A.right : Ot.right, st = nt - Pt, Q = W - kt;
            return {
              top: kt,
              bottom: W,
              left: Pt,
              right: nt,
              width: st,
              height: Q,
              x: Pt,
              y: kt
            };
          }
          const g = X(e) === "left", S = K(...d.map((A) => A.right)), E = It(...d.map((A) => A.left)), x = d.filter((A) => g ? A.left === E : A.right === S), $ = x[0].top, O = x[x.length - 1].bottom, _ = E, L = S, D = L - _, F = O - $;
          return {
            top: $,
            bottom: O,
            left: _,
            right: L,
            width: D,
            height: F,
            x: _,
            y: $
          };
        }
        return f;
      }
      const v = await r.getElementRects({
        reference: {
          getBoundingClientRect: b
        },
        floating: s.floating,
        strategy: o
      });
      return n.reference.x !== v.reference.x || n.reference.y !== v.reference.y || n.reference.width !== v.reference.width || n.reference.height !== v.reference.height ? {
        reset: {
          rects: v
        }
      } : {};
    }
  };
};
async function Zs(i, t) {
  const {
    placement: e,
    platform: s,
    elements: n
  } = i, r = await (s.isRTL == null ? void 0 : s.isRTL(n.floating)), o = X(e), a = Me(e), l = Ct(e) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = r && l ? -1 : 1, d = ae(t, i);
  let {
    mainAxis: f,
    crossAxis: p,
    alignmentAxis: b
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return a && typeof b == "number" && (p = a === "end" ? b * -1 : b), l ? {
    x: p * u,
    y: f * c
  } : {
    x: f * c,
    y: p * u
  };
}
var Vn = function(i) {
  return {
    name: "offset",
    options: i,
    async fn(t) {
      var e, s;
      const {
        x: n,
        y: r,
        placement: o,
        middlewareData: a
      } = t, l = await Zs(t, i);
      return o === ((e = a.offset) == null ? void 0 : e.placement) && (s = a.arrow) != null && s.alignmentOffset ? {} : {
        x: n + l.x,
        y: r + l.y,
        data: {
          ...l,
          placement: o
        }
      };
    }
  };
};
var tr = function(i) {
  return i === void 0 && (i = {}), {
    name: "shift",
    options: i,
    async fn(t) {
      const {
        x: e,
        y: s,
        placement: n
      } = t, {
        mainAxis: r = true,
        crossAxis: o = false,
        limiter: a = {
          fn: (g) => {
            let {
              x: S,
              y: E
            } = g;
            return {
              x: S,
              y: E
            };
          }
        },
        ...l
      } = ae(i, t), c = {
        x: e,
        y: s
      }, u = await Dn(t, l), d = Ct(X(n)), f = jn(d);
      let p = c[f], b = c[d];
      if (r) {
        const g = f === "y" ? "top" : "left", S = f === "y" ? "bottom" : "right", E = p + u[g], x = p - u[S];
        p = Zi(E, p, x);
      }
      if (o) {
        const g = d === "y" ? "top" : "left", S = d === "y" ? "bottom" : "right", E = b + u[g], x = b - u[S];
        b = Zi(E, b, x);
      }
      const v = a.fn({
        ...t,
        [f]: p,
        [d]: b
      });
      return {
        ...v,
        data: {
          x: v.x - e,
          y: v.y - s
        }
      };
    }
  };
};
function ut(i) {
  return Un(i) ? (i.nodeName || "").toLowerCase() : "#document";
}
function j(i) {
  var t;
  return (i == null || (t = i.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function gt(i) {
  var t;
  return (t = (Un(i) ? i.ownerDocument : i.document) || window.document) == null ? void 0 : t.documentElement;
}
function Un(i) {
  return i instanceof Node || i instanceof j(i).Node;
}
function Y(i) {
  return i instanceof Element || i instanceof j(i).Element;
}
function G(i) {
  return i instanceof HTMLElement || i instanceof j(i).HTMLElement;
}
function en(i) {
  return typeof ShadowRoot > "u" ? false : i instanceof ShadowRoot || i instanceof j(i).ShadowRoot;
}
function ce(i) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: s,
    display: n
  } = B(i);
  return /auto|scroll|overlay|hidden|clip/.test(t + s + e) && !["inline", "contents"].includes(n);
}
function er(i) {
  return ["table", "td", "th"].includes(ut(i));
}
function ir(i) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return i.matches(t);
    } catch {
      return false;
    }
  });
}
function mi(i) {
  const t = bi(), e = Y(i) ? B(i) : i;
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : false) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : false) || !t && (e.filter ? e.filter !== "none" : false) || ["transform", "perspective", "filter"].some((s) => (e.willChange || "").includes(s)) || ["paint", "layout", "strict", "content"].some((s) => (e.contain || "").includes(s));
}
function nr(i) {
  let t = zt(i);
  for (; G(t) && !je(t); ) {
    if (mi(t))
      return t;
    if (ir(t))
      return null;
    t = zt(t);
  }
  return null;
}
function bi() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function je(i) {
  return ["html", "body", "#document"].includes(ut(i));
}
function B(i) {
  return j(i).getComputedStyle(i);
}
function Be(i) {
  return Y(i) ? {
    scrollLeft: i.scrollLeft,
    scrollTop: i.scrollTop
  } : {
    scrollLeft: i.scrollX,
    scrollTop: i.scrollY
  };
}
function zt(i) {
  if (ut(i) === "html")
    return i;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    i.assignedSlot || // DOM Element detected.
    i.parentNode || // ShadowRoot detected.
    en(i) && i.host || // Fallback.
    gt(i)
  );
  return en(t) ? t.host : t;
}
function qn(i) {
  const t = zt(i);
  return je(t) ? i.ownerDocument ? i.ownerDocument.body : i.body : G(t) && ce(t) ? t : qn(t);
}
function ii(i, t, e) {
  var s;
  t === void 0 && (t = []), e === void 0 && (e = true);
  const n = qn(i), r = n === ((s = i.ownerDocument) == null ? void 0 : s.body), o = j(n);
  if (r) {
    const a = sr(o);
    return t.concat(o, o.visualViewport || [], ce(n) ? n : [], a && e ? ii(a) : []);
  }
  return t.concat(n, ii(n, [], e));
}
function sr(i) {
  return i.parent && Object.getPrototypeOf(i.parent) ? i.frameElement : null;
}
function Wn(i) {
  const t = B(i);
  let e = parseFloat(t.width) || 0, s = parseFloat(t.height) || 0;
  const n = G(i), r = n ? i.offsetWidth : e, o = n ? i.offsetHeight : s, a = we(e) !== r || we(s) !== o;
  return a && (e = r, s = o), {
    width: e,
    height: s,
    $: a
  };
}
function Qn(i) {
  return Y(i) ? i : i.contextElement;
}
function Lt(i) {
  const t = Qn(i);
  if (!G(t))
    return ct(1);
  const e = t.getBoundingClientRect(), {
    width: s,
    height: n,
    $: r
  } = Wn(t);
  let o = (r ? we(e.width) : e.width) / s, a = (r ? we(e.height) : e.height) / n;
  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: o,
    y: a
  };
}
var rr = ct(0);
function Yn(i) {
  const t = j(i);
  return !bi() || !t.visualViewport ? rr : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function or(i, t, e) {
  return t === void 0 && (t = false), !e || t && e !== j(i) ? false : t;
}
function te(i, t, e, s) {
  t === void 0 && (t = false), e === void 0 && (e = false);
  const n = i.getBoundingClientRect(), r = Qn(i);
  let o = ct(1);
  t && (s ? Y(s) && (o = Lt(s)) : o = Lt(i));
  const a = or(r, e, s) ? Yn(r) : ct(0);
  let l = (n.left + a.x) / o.x, c = (n.top + a.y) / o.y, u = n.width / o.x, d = n.height / o.y;
  if (r) {
    const f = j(r), p = s && Y(s) ? j(s) : s;
    let b = f, v = b.frameElement;
    for (; v && s && p !== b; ) {
      const g = Lt(v), S = v.getBoundingClientRect(), E = B(v), x = S.left + (v.clientLeft + parseFloat(E.paddingLeft)) * g.x, $ = S.top + (v.clientTop + parseFloat(E.paddingTop)) * g.y;
      l *= g.x, c *= g.y, u *= g.x, d *= g.y, l += x, c += $, b = j(v), v = b.frameElement;
    }
  }
  return Rt({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
var lr = [":popover-open", ":modal"];
function Gn(i) {
  return lr.some((t) => {
    try {
      return i.matches(t);
    } catch {
      return false;
    }
  });
}
function ar(i) {
  let {
    elements: t,
    rect: e,
    offsetParent: s,
    strategy: n
  } = i;
  const r = n === "fixed", o = gt(s), a = t ? Gn(t.floating) : false;
  if (s === o || a && r)
    return e;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = ct(1);
  const u = ct(0), d = G(s);
  if ((d || !d && !r) && ((ut(s) !== "body" || ce(o)) && (l = Be(s)), G(s))) {
    const f = te(s);
    c = Lt(s), u.x = f.x + s.clientLeft, u.y = f.y + s.clientTop;
  }
  return {
    width: e.width * c.x,
    height: e.height * c.y,
    x: e.x * c.x - l.scrollLeft * c.x + u.x,
    y: e.y * c.y - l.scrollTop * c.y + u.y
  };
}
function cr(i) {
  return Array.from(i.getClientRects());
}
function Kn(i) {
  return te(gt(i)).left + Be(i).scrollLeft;
}
function ur(i) {
  const t = gt(i), e = Be(i), s = i.ownerDocument.body, n = K(t.scrollWidth, t.clientWidth, s.scrollWidth, s.clientWidth), r = K(t.scrollHeight, t.clientHeight, s.scrollHeight, s.clientHeight);
  let o = -e.scrollLeft + Kn(i);
  const a = -e.scrollTop;
  return B(s).direction === "rtl" && (o += K(t.clientWidth, s.clientWidth) - n), {
    width: n,
    height: r,
    x: o,
    y: a
  };
}
function hr(i, t) {
  const e = j(i), s = gt(i), n = e.visualViewport;
  let r = s.clientWidth, o = s.clientHeight, a = 0, l = 0;
  if (n) {
    r = n.width, o = n.height;
    const c = bi();
    (!c || c && t === "fixed") && (a = n.offsetLeft, l = n.offsetTop);
  }
  return {
    width: r,
    height: o,
    x: a,
    y: l
  };
}
function dr(i, t) {
  const e = te(i, true, t === "fixed"), s = e.top + i.clientTop, n = e.left + i.clientLeft, r = G(i) ? Lt(i) : ct(1), o = i.clientWidth * r.x, a = i.clientHeight * r.y, l = n * r.x, c = s * r.y;
  return {
    width: o,
    height: a,
    x: l,
    y: c
  };
}
function nn(i, t, e) {
  let s;
  if (t === "viewport")
    s = hr(i, e);
  else if (t === "document")
    s = ur(gt(i));
  else if (Y(t))
    s = dr(t, e);
  else {
    const n = Yn(i);
    s = {
      ...t,
      x: t.x - n.x,
      y: t.y - n.y
    };
  }
  return Rt(s);
}
function Xn(i, t) {
  const e = zt(i);
  return e === t || !Y(e) || je(e) ? false : B(e).position === "fixed" || Xn(e, t);
}
function fr(i, t) {
  const e = t.get(i);
  if (e)
    return e;
  let s = ii(i, [], false).filter((a) => Y(a) && ut(a) !== "body"), n = null;
  const r = B(i).position === "fixed";
  let o = r ? zt(i) : i;
  for (; Y(o) && !je(o); ) {
    const a = B(o), l = mi(o);
    !l && a.position === "fixed" && (n = null), (r ? !l && !n : !l && a.position === "static" && !!n && ["absolute", "fixed"].includes(n.position) || ce(o) && !l && Xn(i, o)) ? s = s.filter((u) => u !== o) : n = a, o = zt(o);
  }
  return t.set(i, s), s;
}
function pr(i) {
  let {
    element: t,
    boundary: e,
    rootBoundary: s,
    strategy: n
  } = i;
  const o = [...e === "clippingAncestors" ? fr(t, this._c) : [].concat(e), s], a = o[0], l = o.reduce((c, u) => {
    const d = nn(t, u, n);
    return c.top = K(d.top, c.top), c.right = It(d.right, c.right), c.bottom = It(d.bottom, c.bottom), c.left = K(d.left, c.left), c;
  }, nn(t, a, n));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function mr(i) {
  const {
    width: t,
    height: e
  } = Wn(i);
  return {
    width: t,
    height: e
  };
}
function br(i, t, e) {
  const s = G(t), n = gt(t), r = e === "fixed", o = te(i, true, r, t);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = ct(0);
  if (s || !s && !r)
    if ((ut(t) !== "body" || ce(n)) && (a = Be(t)), s) {
      const d = te(t, true, r, t);
      l.x = d.x + t.clientLeft, l.y = d.y + t.clientTop;
    } else
      n && (l.x = Kn(n));
  const c = o.left + a.scrollLeft - l.x, u = o.top + a.scrollTop - l.y;
  return {
    x: c,
    y: u,
    width: o.width,
    height: o.height
  };
}
function sn(i, t) {
  return !G(i) || B(i).position === "fixed" ? null : t ? t(i) : i.offsetParent;
}
function Jn(i, t) {
  const e = j(i);
  if (!G(i) || Gn(i))
    return e;
  let s = sn(i, t);
  for (; s && er(s) && B(s).position === "static"; )
    s = sn(s, t);
  return s && (ut(s) === "html" || ut(s) === "body" && B(s).position === "static" && !mi(s)) ? e : s || nr(i) || e;
}
var gr = async function(i) {
  const t = this.getOffsetParent || Jn, e = this.getDimensions;
  return {
    reference: br(i.reference, await t(i.floating), i.strategy),
    floating: {
      x: 0,
      y: 0,
      ...await e(i.floating)
    }
  };
};
function vr(i) {
  return B(i).direction === "rtl";
}
var yr = {
  convertOffsetParentRelativeRectToViewportRelativeRect: ar,
  getDocumentElement: gt,
  getClippingRect: pr,
  getOffsetParent: Jn,
  getElementRects: gr,
  getClientRects: cr,
  getDimensions: mr,
  getScale: Lt,
  isElement: Y,
  isRTL: vr
};
var Zn = tr;
var ts = Ks;
var es = Js;
var is = (i, t, e) => {
  const s = /* @__PURE__ */ new Map(), n = {
    platform: yr,
    ...e
  }, r = {
    ...n.platform,
    _c: s
  };
  return Gs(i, t, {
    ...n,
    platform: r
  });
};
var ye = globalThis;
var gi = ye.ShadowRoot && (ye.ShadyCSS === void 0 || ye.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
var vi = Symbol();
var rn = /* @__PURE__ */ new WeakMap();
var ns = class {
  constructor(t, e, s) {
    if (this._$cssResult$ = true, s !== vi)
      throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
    this.cssText = t, this.t = e;
  }
  get styleSheet() {
    let t = this.o;
    const e = this.t;
    if (gi && t === void 0) {
      const s = e !== void 0 && e.length === 1;
      s && (t = rn.get(e)), t === void 0 && ((this.o = t = new CSSStyleSheet()).replaceSync(this.cssText), s && rn.set(e, t));
    }
    return t;
  }
  toString() {
    return this.cssText;
  }
};
var _r = (i) => new ns(typeof i == "string" ? i : i + "", void 0, vi);
var C = (i, ...t) => {
  const e = i.length === 1 ? i[0] : t.reduce((s, n, r) => s + ((o) => {
    if (o._$cssResult$ === true)
      return o.cssText;
    if (typeof o == "number")
      return o;
    throw Error("Value passed to 'css' function must be a 'css' function result: " + o + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
  })(n) + i[r + 1], i[0]);
  return new ns(e, i, vi);
};
var xr = (i, t) => {
  if (gi)
    i.adoptedStyleSheets = t.map((e) => e instanceof CSSStyleSheet ? e : e.styleSheet);
  else
    for (const e of t) {
      const s = document.createElement("style"), n = ye.litNonce;
      n !== void 0 && s.setAttribute("nonce", n), s.textContent = e.cssText, i.appendChild(s);
    }
};
var on = gi ? (i) => i : (i) => i instanceof CSSStyleSheet ? ((t) => {
  let e = "";
  for (const s of t.cssRules)
    e += s.cssText;
  return _r(e);
})(i) : i;
var { is: wr, defineProperty: $r, getOwnPropertyDescriptor: Cr, getOwnPropertyNames: Er, getOwnPropertySymbols: Sr, getPrototypeOf: Ar } = Object;
var at = globalThis;
var ln = at.trustedTypes;
var Or = ln ? ln.emptyScript : "";
var We = at.reactiveElementPolyfillSupport;
var Gt = (i, t) => i;
var Ce = { toAttribute(i, t) {
  switch (t) {
    case Boolean:
      i = i ? Or : null;
      break;
    case Object:
    case Array:
      i = i == null ? i : JSON.stringify(i);
  }
  return i;
}, fromAttribute(i, t) {
  let e = i;
  switch (t) {
    case Boolean:
      e = i !== null;
      break;
    case Number:
      e = i === null ? null : Number(i);
      break;
    case Object:
    case Array:
      try {
        e = JSON.parse(i);
      } catch {
        e = null;
      }
  }
  return e;
} };
var yi = (i, t) => !wr(i, t);
var an = { attribute: true, type: String, converter: Ce, reflect: false, hasChanged: yi };
Symbol.metadata ?? (Symbol.metadata = Symbol("metadata")), at.litPropertyMetadata ?? (at.litPropertyMetadata = /* @__PURE__ */ new WeakMap());
var Tt = class extends HTMLElement {
  static addInitializer(t) {
    this._$Ei(), (this.l ?? (this.l = [])).push(t);
  }
  static get observedAttributes() {
    return this.finalize(), this._$Eh && [...this._$Eh.keys()];
  }
  static createProperty(t, e = an) {
    if (e.state && (e.attribute = false), this._$Ei(), this.elementProperties.set(t, e), !e.noAccessor) {
      const s = Symbol(), n = this.getPropertyDescriptor(t, s, e);
      n !== void 0 && $r(this.prototype, t, n);
    }
  }
  static getPropertyDescriptor(t, e, s) {
    const { get: n, set: r } = Cr(this.prototype, t) ?? { get() {
      return this[e];
    }, set(o) {
      this[e] = o;
    } };
    return { get() {
      return n == null ? void 0 : n.call(this);
    }, set(o) {
      const a = n == null ? void 0 : n.call(this);
      r.call(this, o), this.requestUpdate(t, a, s);
    }, configurable: true, enumerable: true };
  }
  static getPropertyOptions(t) {
    return this.elementProperties.get(t) ?? an;
  }
  static _$Ei() {
    if (this.hasOwnProperty(Gt("elementProperties")))
      return;
    const t = Ar(this);
    t.finalize(), t.l !== void 0 && (this.l = [...t.l]), this.elementProperties = new Map(t.elementProperties);
  }
  static finalize() {
    if (this.hasOwnProperty(Gt("finalized")))
      return;
    if (this.finalized = true, this._$Ei(), this.hasOwnProperty(Gt("properties"))) {
      const e = this.properties, s = [...Er(e), ...Sr(e)];
      for (const n of s)
        this.createProperty(n, e[n]);
    }
    const t = this[Symbol.metadata];
    if (t !== null) {
      const e = litPropertyMetadata.get(t);
      if (e !== void 0)
        for (const [s, n] of e)
          this.elementProperties.set(s, n);
    }
    this._$Eh = /* @__PURE__ */ new Map();
    for (const [e, s] of this.elementProperties) {
      const n = this._$Eu(e, s);
      n !== void 0 && this._$Eh.set(n, e);
    }
    this.elementStyles = this.finalizeStyles(this.styles);
  }
  static finalizeStyles(t) {
    const e = [];
    if (Array.isArray(t)) {
      const s = new Set(t.flat(1 / 0).reverse());
      for (const n of s)
        e.unshift(on(n));
    } else
      t !== void 0 && e.push(on(t));
    return e;
  }
  static _$Eu(t, e) {
    const s = e.attribute;
    return s === false ? void 0 : typeof s == "string" ? s : typeof t == "string" ? t.toLowerCase() : void 0;
  }
  constructor() {
    super(), this._$Ep = void 0, this.isUpdatePending = false, this.hasUpdated = false, this._$Em = null, this._$Ev();
  }
  _$Ev() {
    var t;
    this._$ES = new Promise((e) => this.enableUpdating = e), this._$AL = /* @__PURE__ */ new Map(), this._$E_(), this.requestUpdate(), (t = this.constructor.l) == null || t.forEach((e) => e(this));
  }
  addController(t) {
    var e;
    (this._$EO ?? (this._$EO = /* @__PURE__ */ new Set())).add(t), this.renderRoot !== void 0 && this.isConnected && ((e = t.hostConnected) == null || e.call(t));
  }
  removeController(t) {
    var e;
    (e = this._$EO) == null || e.delete(t);
  }
  _$E_() {
    const t = /* @__PURE__ */ new Map(), e = this.constructor.elementProperties;
    for (const s of e.keys())
      this.hasOwnProperty(s) && (t.set(s, this[s]), delete this[s]);
    t.size > 0 && (this._$Ep = t);
  }
  createRenderRoot() {
    const t = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
    return xr(t, this.constructor.elementStyles), t;
  }
  connectedCallback() {
    var t;
    this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostConnected) == null ? void 0 : s.call(e);
    });
  }
  enableUpdating(t) {
  }
  disconnectedCallback() {
    var t;
    (t = this._$EO) == null || t.forEach((e) => {
      var s;
      return (s = e.hostDisconnected) == null ? void 0 : s.call(e);
    });
  }
  attributeChangedCallback(t, e, s) {
    this._$AK(t, s);
  }
  _$EC(t, e) {
    var r;
    const s = this.constructor.elementProperties.get(t), n = this.constructor._$Eu(t, s);
    if (n !== void 0 && s.reflect === true) {
      const o = (((r = s.converter) == null ? void 0 : r.toAttribute) !== void 0 ? s.converter : Ce).toAttribute(e, s.type);
      this._$Em = t, o == null ? this.removeAttribute(n) : this.setAttribute(n, o), this._$Em = null;
    }
  }
  _$AK(t, e) {
    var r;
    const s = this.constructor, n = s._$Eh.get(t);
    if (n !== void 0 && this._$Em !== n) {
      const o = s.getPropertyOptions(n), a = typeof o.converter == "function" ? { fromAttribute: o.converter } : ((r = o.converter) == null ? void 0 : r.fromAttribute) !== void 0 ? o.converter : Ce;
      this._$Em = n, this[n] = a.fromAttribute(e, o.type), this._$Em = null;
    }
  }
  requestUpdate(t, e, s) {
    if (t !== void 0) {
      if (s ?? (s = this.constructor.getPropertyOptions(t)), !(s.hasChanged ?? yi)(this[t], e))
        return;
      this.P(t, e, s);
    }
    this.isUpdatePending === false && (this._$ES = this._$ET());
  }
  P(t, e, s) {
    this._$AL.has(t) || this._$AL.set(t, e), s.reflect === true && this._$Em !== t && (this._$Ej ?? (this._$Ej = /* @__PURE__ */ new Set())).add(t);
  }
  async _$ET() {
    this.isUpdatePending = true;
    try {
      await this._$ES;
    } catch (e) {
      Promise.reject(e);
    }
    const t = this.scheduleUpdate();
    return t != null && await t, !this.isUpdatePending;
  }
  scheduleUpdate() {
    return this.performUpdate();
  }
  performUpdate() {
    var s;
    if (!this.isUpdatePending)
      return;
    if (!this.hasUpdated) {
      if (this.renderRoot ?? (this.renderRoot = this.createRenderRoot()), this._$Ep) {
        for (const [r, o] of this._$Ep)
          this[r] = o;
        this._$Ep = void 0;
      }
      const n = this.constructor.elementProperties;
      if (n.size > 0)
        for (const [r, o] of n)
          o.wrapped !== true || this._$AL.has(r) || this[r] === void 0 || this.P(r, this[r], o);
    }
    let t = false;
    const e = this._$AL;
    try {
      t = this.shouldUpdate(e), t ? (this.willUpdate(e), (s = this._$EO) == null || s.forEach((n) => {
        var r;
        return (r = n.hostUpdate) == null ? void 0 : r.call(n);
      }), this.update(e)) : this._$EU();
    } catch (n) {
      throw t = false, this._$EU(), n;
    }
    t && this._$AE(e);
  }
  willUpdate(t) {
  }
  _$AE(t) {
    var e;
    (e = this._$EO) == null || e.forEach((s) => {
      var n;
      return (n = s.hostUpdated) == null ? void 0 : n.call(s);
    }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t)), this.updated(t);
  }
  _$EU() {
    this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
  }
  get updateComplete() {
    return this.getUpdateComplete();
  }
  getUpdateComplete() {
    return this._$ES;
  }
  shouldUpdate(t) {
    return true;
  }
  update(t) {
    this._$Ej && (this._$Ej = this._$Ej.forEach((e) => this._$EC(e, this[e]))), this._$EU();
  }
  updated(t) {
  }
  firstUpdated(t) {
  }
};
Tt.elementStyles = [], Tt.shadowRootOptions = { mode: "open" }, Tt[Gt("elementProperties")] = /* @__PURE__ */ new Map(), Tt[Gt("finalized")] = /* @__PURE__ */ new Map(), We == null || We({ ReactiveElement: Tt }), (at.reactiveElementVersions ?? (at.reactiveElementVersions = [])).push("2.0.4");
var Kt = globalThis;
var Ee = Kt.trustedTypes;
var cn = Ee ? Ee.createPolicy("lit-html", { createHTML: (i) => i }) : void 0;
var ss = "$lit$";
var lt = `lit$${Math.random().toFixed(9).slice(2)}$`;
var rs = "?" + lt;
var kr = `<${rs}>`;
var Et = document;
var ee = () => Et.createComment("");
var ie = (i) => i === null || typeof i != "object" && typeof i != "function";
var _i = Array.isArray;
var Pr = (i) => _i(i) || typeof (i == null ? void 0 : i[Symbol.iterator]) == "function";
var Qe = `[ 	
\f\r]`;
var Qt = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
var un = /-->/g;
var hn = />/g;
var xt = RegExp(`>|${Qe}(?:([^\\s"'>=/]+)(${Qe}*=${Qe}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
var dn = /'/g;
var fn = /"/g;
var os = /^(?:script|style|textarea|title)$/i;
var Tr = (i) => (t, ...e) => ({ _$litType$: i, strings: t, values: e });
var m = Tr(1);
var St = Symbol.for("lit-noChange");
var k = Symbol.for("lit-nothing");
var pn = /* @__PURE__ */ new WeakMap();
var wt = Et.createTreeWalker(Et, 129);
function ls(i, t) {
  if (!_i(i) || !i.hasOwnProperty("raw"))
    throw Error("invalid template strings array");
  return cn !== void 0 ? cn.createHTML(t) : t;
}
var Lr = (i, t) => {
  const e = i.length - 1, s = [];
  let n, r = t === 2 ? "<svg>" : t === 3 ? "<math>" : "", o = Qt;
  for (let a = 0; a < e; a++) {
    const l = i[a];
    let c, u, d = -1, f = 0;
    for (; f < l.length && (o.lastIndex = f, u = o.exec(l), u !== null); )
      f = o.lastIndex, o === Qt ? u[1] === "!--" ? o = un : u[1] !== void 0 ? o = hn : u[2] !== void 0 ? (os.test(u[2]) && (n = RegExp("</" + u[2], "g")), o = xt) : u[3] !== void 0 && (o = xt) : o === xt ? u[0] === ">" ? (o = n ?? Qt, d = -1) : u[1] === void 0 ? d = -2 : (d = o.lastIndex - u[2].length, c = u[1], o = u[3] === void 0 ? xt : u[3] === '"' ? fn : dn) : o === fn || o === dn ? o = xt : o === un || o === hn ? o = Qt : (o = xt, n = void 0);
    const p = o === xt && i[a + 1].startsWith("/>") ? " " : "";
    r += o === Qt ? l + kr : d >= 0 ? (s.push(c), l.slice(0, d) + ss + l.slice(d) + lt + p) : l + lt + (d === -2 ? a : p);
  }
  return [ls(i, r + (i[e] || "<?>") + (t === 2 ? "</svg>" : t === 3 ? "</math>" : "")), s];
};
var ne = class _ne {
  constructor({ strings: t, _$litType$: e }, s) {
    let n;
    this.parts = [];
    let r = 0, o = 0;
    const a = t.length - 1, l = this.parts, [c, u] = Lr(t, e);
    if (this.el = _ne.createElement(c, s), wt.currentNode = this.el.content, e === 2 || e === 3) {
      const d = this.el.content.firstChild;
      d.replaceWith(...d.childNodes);
    }
    for (; (n = wt.nextNode()) !== null && l.length < a; ) {
      if (n.nodeType === 1) {
        if (n.hasAttributes())
          for (const d of n.getAttributeNames())
            if (d.endsWith(ss)) {
              const f = u[o++], p = n.getAttribute(d).split(lt), b = /([.?@])?(.*)/.exec(f);
              l.push({ type: 1, index: r, name: b[2], strings: p, ctor: b[1] === "." ? Rr : b[1] === "?" ? zr : b[1] === "@" ? Mr : He }), n.removeAttribute(d);
            } else
              d.startsWith(lt) && (l.push({ type: 6, index: r }), n.removeAttribute(d));
        if (os.test(n.tagName)) {
          const d = n.textContent.split(lt), f = d.length - 1;
          if (f > 0) {
            n.textContent = Ee ? Ee.emptyScript : "";
            for (let p = 0; p < f; p++)
              n.append(d[p], ee()), wt.nextNode(), l.push({ type: 2, index: ++r });
            n.append(d[f], ee());
          }
        }
      } else if (n.nodeType === 8)
        if (n.data === rs)
          l.push({ type: 2, index: r });
        else {
          let d = -1;
          for (; (d = n.data.indexOf(lt, d + 1)) !== -1; )
            l.push({ type: 7, index: r }), d += lt.length - 1;
        }
      r++;
    }
  }
  static createElement(t, e) {
    const s = Et.createElement("template");
    return s.innerHTML = t, s;
  }
};
function Mt(i, t, e = i, s) {
  var o, a;
  if (t === St)
    return t;
  let n = s !== void 0 ? (o = e.o) == null ? void 0 : o[s] : e.l;
  const r = ie(t) ? void 0 : t._$litDirective$;
  return (n == null ? void 0 : n.constructor) !== r && ((a = n == null ? void 0 : n._$AO) == null || a.call(n, false), r === void 0 ? n = void 0 : (n = new r(i), n._$AT(i, e, s)), s !== void 0 ? (e.o ?? (e.o = []))[s] = n : e.l = n), n !== void 0 && (t = Mt(i, n._$AS(i, t.values), n, s)), t;
}
var Ir = class {
  constructor(t, e) {
    this._$AV = [], this._$AN = void 0, this._$AD = t, this._$AM = e;
  }
  get parentNode() {
    return this._$AM.parentNode;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  u(t) {
    const { el: { content: e }, parts: s } = this._$AD, n = ((t == null ? void 0 : t.creationScope) ?? Et).importNode(e, true);
    wt.currentNode = n;
    let r = wt.nextNode(), o = 0, a = 0, l = s[0];
    for (; l !== void 0; ) {
      if (o === l.index) {
        let c;
        l.type === 2 ? c = new ue(r, r.nextSibling, this, t) : l.type === 1 ? c = new l.ctor(r, l.name, l.strings, this, t) : l.type === 6 && (c = new jr(r, this, t)), this._$AV.push(c), l = s[++a];
      }
      o !== (l == null ? void 0 : l.index) && (r = wt.nextNode(), o++);
    }
    return wt.currentNode = Et, n;
  }
  p(t) {
    let e = 0;
    for (const s of this._$AV)
      s !== void 0 && (s.strings !== void 0 ? (s._$AI(t, s, e), e += s.strings.length - 2) : s._$AI(t[e])), e++;
  }
};
var ue = class _ue {
  get _$AU() {
    var t;
    return ((t = this._$AM) == null ? void 0 : t._$AU) ?? this.v;
  }
  constructor(t, e, s, n) {
    this.type = 2, this._$AH = k, this._$AN = void 0, this._$AA = t, this._$AB = e, this._$AM = s, this.options = n, this.v = (n == null ? void 0 : n.isConnected) ?? true;
  }
  get parentNode() {
    let t = this._$AA.parentNode;
    const e = this._$AM;
    return e !== void 0 && (t == null ? void 0 : t.nodeType) === 11 && (t = e.parentNode), t;
  }
  get startNode() {
    return this._$AA;
  }
  get endNode() {
    return this._$AB;
  }
  _$AI(t, e = this) {
    t = Mt(this, t, e), ie(t) ? t === k || t == null || t === "" ? (this._$AH !== k && this._$AR(), this._$AH = k) : t !== this._$AH && t !== St && this._(t) : t._$litType$ !== void 0 ? this.$(t) : t.nodeType !== void 0 ? this.T(t) : Pr(t) ? this.k(t) : this._(t);
  }
  O(t) {
    return this._$AA.parentNode.insertBefore(t, this._$AB);
  }
  T(t) {
    this._$AH !== t && (this._$AR(), this._$AH = this.O(t));
  }
  _(t) {
    this._$AH !== k && ie(this._$AH) ? this._$AA.nextSibling.data = t : this.T(Et.createTextNode(t)), this._$AH = t;
  }
  $(t) {
    var r;
    const { values: e, _$litType$: s } = t, n = typeof s == "number" ? this._$AC(t) : (s.el === void 0 && (s.el = ne.createElement(ls(s.h, s.h[0]), this.options)), s);
    if (((r = this._$AH) == null ? void 0 : r._$AD) === n)
      this._$AH.p(e);
    else {
      const o = new Ir(n, this), a = o.u(this.options);
      o.p(e), this.T(a), this._$AH = o;
    }
  }
  _$AC(t) {
    let e = pn.get(t.strings);
    return e === void 0 && pn.set(t.strings, e = new ne(t)), e;
  }
  k(t) {
    _i(this._$AH) || (this._$AH = [], this._$AR());
    const e = this._$AH;
    let s, n = 0;
    for (const r of t)
      n === e.length ? e.push(s = new _ue(this.O(ee()), this.O(ee()), this, this.options)) : s = e[n], s._$AI(r), n++;
    n < e.length && (this._$AR(s && s._$AB.nextSibling, n), e.length = n);
  }
  _$AR(t = this._$AA.nextSibling, e) {
    var s;
    for ((s = this._$AP) == null ? void 0 : s.call(this, false, true, e); t && t !== this._$AB; ) {
      const n = t.nextSibling;
      t.remove(), t = n;
    }
  }
  setConnected(t) {
    var e;
    this._$AM === void 0 && (this.v = t, (e = this._$AP) == null || e.call(this, t));
  }
};
var He = class {
  get tagName() {
    return this.element.tagName;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  constructor(t, e, s, n, r) {
    this.type = 1, this._$AH = k, this._$AN = void 0, this.element = t, this.name = e, this._$AM = n, this.options = r, s.length > 2 || s[0] !== "" || s[1] !== "" ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = k;
  }
  _$AI(t, e = this, s, n) {
    const r = this.strings;
    let o = false;
    if (r === void 0)
      t = Mt(this, t, e, 0), o = !ie(t) || t !== this._$AH && t !== St, o && (this._$AH = t);
    else {
      const a = t;
      let l, c;
      for (t = r[0], l = 0; l < r.length - 1; l++)
        c = Mt(this, a[s + l], e, l), c === St && (c = this._$AH[l]), o || (o = !ie(c) || c !== this._$AH[l]), c === k ? t = k : t !== k && (t += (c ?? "") + r[l + 1]), this._$AH[l] = c;
    }
    o && !n && this.j(t);
  }
  j(t) {
    t === k ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, t ?? "");
  }
};
var Rr = class extends He {
  constructor() {
    super(...arguments), this.type = 3;
  }
  j(t) {
    this.element[this.name] = t === k ? void 0 : t;
  }
};
var zr = class extends He {
  constructor() {
    super(...arguments), this.type = 4;
  }
  j(t) {
    this.element.toggleAttribute(this.name, !!t && t !== k);
  }
};
var Mr = class extends He {
  constructor(t, e, s, n, r) {
    super(t, e, s, n, r), this.type = 5;
  }
  _$AI(t, e = this) {
    if ((t = Mt(this, t, e, 0) ?? k) === St)
      return;
    const s = this._$AH, n = t === k && s !== k || t.capture !== s.capture || t.once !== s.once || t.passive !== s.passive, r = t !== k && (s === k || n);
    n && this.element.removeEventListener(this.name, this, s), r && this.element.addEventListener(this.name, this, t), this._$AH = t;
  }
  handleEvent(t) {
    var e;
    typeof this._$AH == "function" ? this._$AH.call(((e = this.options) == null ? void 0 : e.host) ?? this.element, t) : this._$AH.handleEvent(t);
  }
};
var jr = class {
  constructor(t, e, s) {
    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = e, this.options = s;
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AI(t) {
    Mt(this, t);
  }
};
var Ye = Kt.litHtmlPolyfillSupport;
Ye == null || Ye(ne, ue), (Kt.litHtmlVersions ?? (Kt.litHtmlVersions = [])).push("3.2.0");
var jt = (i, t, e) => {
  const s = (e == null ? void 0 : e.renderBefore) ?? t;
  let n = s._$litPart$;
  if (n === void 0) {
    const r = (e == null ? void 0 : e.renderBefore) ?? null;
    s._$litPart$ = n = new ue(t.insertBefore(ee(), r), r, void 0, e ?? {});
  }
  return n._$AI(i), n;
};
var w = class extends Tt {
  constructor() {
    super(...arguments), this.renderOptions = { host: this }, this.o = void 0;
  }
  createRenderRoot() {
    var e;
    const t = super.createRenderRoot();
    return (e = this.renderOptions).renderBefore ?? (e.renderBefore = t.firstChild), t;
  }
  update(t) {
    const e = this.render();
    this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t), this.o = jt(e, this.renderRoot, this.renderOptions);
  }
  connectedCallback() {
    var t;
    super.connectedCallback(), (t = this.o) == null || t.setConnected(true);
  }
  disconnectedCallback() {
    var t;
    super.disconnectedCallback(), (t = this.o) == null || t.setConnected(false);
  }
  render() {
    return St;
  }
};
var Mn;
w._$litElement$ = true, w.finalized = true, (Mn = globalThis.litElementHydrateSupport) == null || Mn.call(globalThis, { LitElement: w });
var Ge = globalThis.litElementPolyfillSupport;
Ge == null || Ge({ LitElement: w });
(globalThis.litElementVersions ?? (globalThis.litElementVersions = [])).push("4.1.0");
var Br = { attribute: true, type: String, converter: Ce, reflect: false, hasChanged: yi };
var Hr = (i = Br, t, e) => {
  const { kind: s, metadata: n } = e;
  let r = globalThis.litPropertyMetadata.get(n);
  if (r === void 0 && globalThis.litPropertyMetadata.set(n, r = /* @__PURE__ */ new Map()), r.set(e.name, i), s === "accessor") {
    const { name: o } = e;
    return { set(a) {
      const l = t.get.call(this);
      t.set.call(this, a), this.requestUpdate(o, l, i);
    }, init(a) {
      return a !== void 0 && this.P(o, void 0, i), a;
    } };
  }
  if (s === "setter") {
    const { name: o } = e;
    return function(a) {
      const l = this[o];
      t.call(this, a), this.requestUpdate(o, l, i);
    };
  }
  throw Error("Unsupported decorator location: " + s);
};
function h(i) {
  return (t, e) => typeof e == "object" ? Hr(i, t, e) : ((s, n, r) => {
    const o = n.hasOwnProperty(r);
    return n.constructor.createProperty(r, o ? { ...s, wrapped: true } : s), o ? Object.getOwnPropertyDescriptor(n, r) : void 0;
  })(i, t, e);
}
function Ft(i) {
  return h({ ...i, state: true, attribute: false });
}
var Nr = (i) => i.strings === void 0;
var as = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
var cs = (i) => (...t) => ({ _$litDirective$: i, values: t });
var us = class {
  constructor(t) {
  }
  get _$AU() {
    return this._$AM._$AU;
  }
  _$AT(t, e, s) {
    this.t = t, this._$AM = e, this.i = s;
  }
  _$AS(t, e) {
    return this.update(t, e);
  }
  update(t, e) {
    return this.render(...e);
  }
};
var Xt = (i, t) => {
  var s;
  const e = i._$AN;
  if (e === void 0)
    return false;
  for (const n of e)
    (s = n._$AO) == null || s.call(n, t, false), Xt(n, t);
  return true;
};
var Se = (i) => {
  let t, e;
  do {
    if ((t = i._$AM) === void 0)
      break;
    e = t._$AN, e.delete(i), i = t;
  } while ((e == null ? void 0 : e.size) === 0);
};
var hs = (i) => {
  for (let t; t = i._$AM; i = t) {
    let e = t._$AN;
    if (e === void 0)
      t._$AN = e = /* @__PURE__ */ new Set();
    else if (e.has(i))
      break;
    e.add(i), Vr(t);
  }
};
function Dr(i) {
  this._$AN !== void 0 ? (Se(this), this._$AM = i, hs(this)) : this._$AM = i;
}
function Fr(i, t = false, e = 0) {
  const s = this._$AH, n = this._$AN;
  if (n !== void 0 && n.size !== 0)
    if (t)
      if (Array.isArray(s))
        for (let r = e; r < s.length; r++)
          Xt(s[r], false), Se(s[r]);
      else
        s != null && (Xt(s, false), Se(s));
    else
      Xt(this, i);
}
var Vr = (i) => {
  i.type == as.CHILD && (i._$AP ?? (i._$AP = Fr), i._$AQ ?? (i._$AQ = Dr));
};
var Ur = class extends us {
  constructor() {
    super(...arguments), this._$AN = void 0;
  }
  _$AT(t, e, s) {
    super._$AT(t, e, s), hs(this), this.isConnected = t._$AU;
  }
  _$AO(t, e = true) {
    var s, n;
    t !== this.isConnected && (this.isConnected = t, t ? (s = this.reconnected) == null || s.call(this) : (n = this.disconnected) == null || n.call(this)), e && (Xt(this, t), Se(this));
  }
  setValue(t) {
    if (Nr(this.t))
      this.t._$AI(t, this);
    else {
      const e = [...this.t._$AH];
      e[this.i] = t, this.t._$AI(e, this, 0);
    }
  }
  disconnected() {
  }
  reconnected() {
  }
};
var Bt = () => new qr();
var qr = class {
};
var Ke = /* @__PURE__ */ new WeakMap();
var Ht = cs(class extends Ur {
  render(i) {
    return k;
  }
  update(i, [t]) {
    var s;
    const e = t !== this.Y;
    return e && this.Y !== void 0 && this.rt(void 0), (e || this.lt !== this.ct) && (this.Y = t, this.ht = (s = i.options) == null ? void 0 : s.host, this.rt(this.ct = i.element)), k;
  }
  rt(i) {
    if (this.isConnected || (i = void 0), typeof this.Y == "function") {
      const t = this.ht ?? globalThis;
      let e = Ke.get(t);
      e === void 0 && (e = /* @__PURE__ */ new WeakMap(), Ke.set(t, e)), e.get(this.Y) !== void 0 && this.Y.call(this.ht, void 0), e.set(this.Y, i), i !== void 0 && this.Y.call(this.ht, i);
    } else
      this.Y.value = i;
  }
  get lt() {
    var i, t;
    return typeof this.Y == "function" ? (i = Ke.get(this.ht ?? globalThis)) == null ? void 0 : i.get(this.Y) : (t = this.Y) == null ? void 0 : t.value;
  }
  disconnected() {
    this.lt === this.ct && this.rt(void 0);
  }
  reconnected() {
    this.rt(this.ct);
  }
});
var ds = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var Ae = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var he = Object.freeze({
  ...ds,
  ...Ae
});
var ni = Object.freeze({
  ...he,
  body: "",
  hidden: false
});
var Wr = Object.freeze({
  width: null,
  height: null
});
var fs = Object.freeze({
  // Dimensions
  ...Wr,
  // Transformations
  ...Ae
});
function Qr(i, t = 0) {
  const e = i.replace(/^-?[0-9.]*/, "");
  function s(n) {
    for (; n < 0; )
      n += 4;
    return n % 4;
  }
  if (e === "") {
    const n = parseInt(i);
    return isNaN(n) ? 0 : s(n);
  } else if (e !== i) {
    let n = 0;
    switch (e) {
      case "%":
        n = 25;
        break;
      case "deg":
        n = 90;
    }
    if (n) {
      let r = parseFloat(i.slice(0, i.length - e.length));
      return isNaN(r) ? 0 : (r = r / n, r % 1 === 0 ? s(r) : 0);
    }
  }
  return t;
}
var Yr = /[\s,]+/;
function Gr(i, t) {
  t.split(Yr).forEach((e) => {
    switch (e.trim()) {
      case "horizontal":
        i.hFlip = true;
        break;
      case "vertical":
        i.vFlip = true;
        break;
    }
  });
}
var ps = {
  ...fs,
  preserveAspectRatio: ""
};
function mn(i) {
  const t = {
    ...ps
  }, e = (s, n) => i.getAttribute(s) || n;
  return t.width = e("width", null), t.height = e("height", null), t.rotate = Qr(e("rotate", "")), Gr(t, e("flip", "")), t.preserveAspectRatio = e("preserveAspectRatio", e("preserveaspectratio", "")), t;
}
function Kr(i, t) {
  for (const e in ps)
    if (i[e] !== t[e])
      return true;
  return false;
}
var Jt = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var de = (i, t, e, s = "") => {
  const n = i.split(":");
  if (i.slice(0, 1) === "@") {
    if (n.length < 2 || n.length > 3)
      return null;
    s = n.shift().slice(1);
  }
  if (n.length > 3 || !n.length)
    return null;
  if (n.length > 1) {
    const a = n.pop(), l = n.pop(), c = {
      // Allow provider without '@': "provider:prefix:name"
      provider: n.length > 0 ? n[0] : s,
      prefix: l,
      name: a
    };
    return t && !_e(c) ? null : c;
  }
  const r = n[0], o = r.split("-");
  if (o.length > 1) {
    const a = {
      provider: s,
      prefix: o.shift(),
      name: o.join("-")
    };
    return t && !_e(a) ? null : a;
  }
  if (e && s === "") {
    const a = {
      provider: s,
      prefix: "",
      name: r
    };
    return t && !_e(a, e) ? null : a;
  }
  return null;
};
var _e = (i, t) => i ? !!((i.provider === "" || i.provider.match(Jt)) && (t && i.prefix === "" || i.prefix.match(Jt)) && i.name.match(Jt)) : false;
function Xr(i, t) {
  const e = {};
  !i.hFlip != !t.hFlip && (e.hFlip = true), !i.vFlip != !t.vFlip && (e.vFlip = true);
  const s = ((i.rotate || 0) + (t.rotate || 0)) % 4;
  return s && (e.rotate = s), e;
}
function bn(i, t) {
  const e = Xr(i, t);
  for (const s in ni)
    s in Ae ? s in i && !(s in e) && (e[s] = Ae[s]) : s in t ? e[s] = t[s] : s in i && (e[s] = i[s]);
  return e;
}
function Jr(i, t) {
  const e = i.icons, s = i.aliases || /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  function r(o) {
    if (e[o])
      return n[o] = [];
    if (!(o in n)) {
      n[o] = null;
      const a = s[o] && s[o].parent, l = a && r(a);
      l && (n[o] = [a].concat(l));
    }
    return n[o];
  }
  return Object.keys(e).concat(Object.keys(s)).forEach(r), n;
}
function Zr(i, t, e) {
  const s = i.icons, n = i.aliases || /* @__PURE__ */ Object.create(null);
  let r = {};
  function o(a) {
    r = bn(
      s[a] || n[a],
      r
    );
  }
  return o(t), e.forEach(o), bn(i, r);
}
function ms(i, t) {
  const e = [];
  if (typeof i != "object" || typeof i.icons != "object")
    return e;
  i.not_found instanceof Array && i.not_found.forEach((n) => {
    t(n, null), e.push(n);
  });
  const s = Jr(i);
  for (const n in s) {
    const r = s[n];
    r && (t(n, Zr(i, n, r)), e.push(n));
  }
  return e;
}
var to = {
  provider: "",
  aliases: {},
  not_found: {},
  ...ds
};
function Xe(i, t) {
  for (const e in t)
    if (e in i && typeof i[e] != typeof t[e])
      return false;
  return true;
}
function bs(i) {
  if (typeof i != "object" || i === null)
    return null;
  const t = i;
  if (typeof t.prefix != "string" || !i.icons || typeof i.icons != "object" || !Xe(i, to))
    return null;
  const e = t.icons;
  for (const n in e) {
    const r = e[n];
    if (!n.match(Jt) || typeof r.body != "string" || !Xe(
      r,
      ni
    ))
      return null;
  }
  const s = t.aliases || /* @__PURE__ */ Object.create(null);
  for (const n in s) {
    const r = s[n], o = r.parent;
    if (!n.match(Jt) || typeof o != "string" || !e[o] && !s[o] || !Xe(
      r,
      ni
    ))
      return null;
  }
  return t;
}
var Oe = /* @__PURE__ */ Object.create(null);
function eo(i, t) {
  return {
    provider: i,
    prefix: t,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function ht(i, t) {
  const e = Oe[i] || (Oe[i] = /* @__PURE__ */ Object.create(null));
  return e[t] || (e[t] = eo(i, t));
}
function xi(i, t) {
  return bs(t) ? ms(t, (e, s) => {
    s ? i.icons[e] = s : i.missing.add(e);
  }) : [];
}
function io(i, t, e) {
  try {
    if (typeof e.body == "string")
      return i.icons[t] = { ...e }, true;
  } catch {
  }
  return false;
}
function no(i, t) {
  let e = [];
  return (typeof i == "string" ? [i] : Object.keys(Oe)).forEach((n) => {
    (typeof n == "string" && typeof t == "string" ? [t] : Object.keys(Oe[n] || {})).forEach((o) => {
      const a = ht(n, o);
      e = e.concat(
        Object.keys(a.icons).map(
          (l) => (n !== "" ? "@" + n + ":" : "") + o + ":" + l
        )
      );
    });
  }), e;
}
var se = false;
function gs(i) {
  return typeof i == "boolean" && (se = i), se;
}
function re(i) {
  const t = typeof i == "string" ? de(i, true, se) : i;
  if (t) {
    const e = ht(t.provider, t.prefix), s = t.name;
    return e.icons[s] || (e.missing.has(s) ? null : void 0);
  }
}
function vs(i, t) {
  const e = de(i, true, se);
  if (!e)
    return false;
  const s = ht(e.provider, e.prefix);
  return io(s, e.name, t);
}
function gn(i, t) {
  if (typeof i != "object")
    return false;
  if (typeof t != "string" && (t = i.provider || ""), se && !t && !i.prefix) {
    let n = false;
    return bs(i) && (i.prefix = "", ms(i, (r, o) => {
      o && vs(r, o) && (n = true);
    })), n;
  }
  const e = i.prefix;
  if (!_e({
    provider: t,
    prefix: e,
    name: "a"
  }))
    return false;
  const s = ht(t, e);
  return !!xi(s, i);
}
function vn(i) {
  return !!re(i);
}
function so(i) {
  const t = re(i);
  return t ? {
    ...he,
    ...t
  } : null;
}
function ro(i) {
  const t = {
    loaded: [],
    missing: [],
    pending: []
  }, e = /* @__PURE__ */ Object.create(null);
  i.sort((n, r) => n.provider !== r.provider ? n.provider.localeCompare(r.provider) : n.prefix !== r.prefix ? n.prefix.localeCompare(r.prefix) : n.name.localeCompare(r.name));
  let s = {
    provider: "",
    prefix: "",
    name: ""
  };
  return i.forEach((n) => {
    if (s.name === n.name && s.prefix === n.prefix && s.provider === n.provider)
      return;
    s = n;
    const r = n.provider, o = n.prefix, a = n.name, l = e[r] || (e[r] = /* @__PURE__ */ Object.create(null)), c = l[o] || (l[o] = ht(r, o));
    let u;
    a in c.icons ? u = t.loaded : o === "" || c.missing.has(a) ? u = t.missing : u = t.pending;
    const d = {
      provider: r,
      prefix: o,
      name: a
    };
    u.push(d);
  }), t;
}
function ys(i, t) {
  i.forEach((e) => {
    const s = e.loaderCallbacks;
    s && (e.loaderCallbacks = s.filter((n) => n.id !== t));
  });
}
function oo(i) {
  i.pendingCallbacksFlag || (i.pendingCallbacksFlag = true, setTimeout(() => {
    i.pendingCallbacksFlag = false;
    const t = i.loaderCallbacks ? i.loaderCallbacks.slice(0) : [];
    if (!t.length)
      return;
    let e = false;
    const s = i.provider, n = i.prefix;
    t.forEach((r) => {
      const o = r.icons, a = o.pending.length;
      o.pending = o.pending.filter((l) => {
        if (l.prefix !== n)
          return true;
        const c = l.name;
        if (i.icons[c])
          o.loaded.push({
            provider: s,
            prefix: n,
            name: c
          });
        else if (i.missing.has(c))
          o.missing.push({
            provider: s,
            prefix: n,
            name: c
          });
        else
          return e = true, true;
        return false;
      }), o.pending.length !== a && (e || ys([i], r.id), r.callback(
        o.loaded.slice(0),
        o.missing.slice(0),
        o.pending.slice(0),
        r.abort
      ));
    });
  }));
}
var lo = 0;
function ao(i, t, e) {
  const s = lo++, n = ys.bind(null, e, s);
  if (!t.pending.length)
    return n;
  const r = {
    id: s,
    icons: t,
    callback: i,
    abort: n
  };
  return e.forEach((o) => {
    (o.loaderCallbacks || (o.loaderCallbacks = [])).push(r);
  }), n;
}
var si = /* @__PURE__ */ Object.create(null);
function yn(i, t) {
  si[i] = t;
}
function ri(i) {
  return si[i] || si[""];
}
function co(i, t = true, e = false) {
  const s = [];
  return i.forEach((n) => {
    const r = typeof n == "string" ? de(n, t, e) : n;
    r && s.push(r);
  }), s;
}
var uo = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function ho(i, t, e, s) {
  const n = i.resources.length, r = i.random ? Math.floor(Math.random() * n) : i.index;
  let o;
  if (i.random) {
    let _ = i.resources.slice(0);
    for (o = []; _.length > 1; ) {
      const L = Math.floor(Math.random() * _.length);
      o.push(_[L]), _ = _.slice(0, L).concat(_.slice(L + 1));
    }
    o = o.concat(_);
  } else
    o = i.resources.slice(r).concat(i.resources.slice(0, r));
  const a = Date.now();
  let l = "pending", c = 0, u, d = null, f = [], p = [];
  typeof s == "function" && p.push(s);
  function b() {
    d && (clearTimeout(d), d = null);
  }
  function v() {
    l === "pending" && (l = "aborted"), b(), f.forEach((_) => {
      _.status === "pending" && (_.status = "aborted");
    }), f = [];
  }
  function g(_, L) {
    L && (p = []), typeof _ == "function" && p.push(_);
  }
  function S() {
    return {
      startTime: a,
      payload: t,
      status: l,
      queriesSent: c,
      queriesPending: f.length,
      subscribe: g,
      abort: v
    };
  }
  function E() {
    l = "failed", p.forEach((_) => {
      _(void 0, u);
    });
  }
  function x() {
    f.forEach((_) => {
      _.status === "pending" && (_.status = "aborted");
    }), f = [];
  }
  function $(_, L, D) {
    const F = L !== "success";
    switch (f = f.filter((A) => A !== _), l) {
      case "pending":
        break;
      case "failed":
        if (F || !i.dataAfterTimeout)
          return;
        break;
      default:
        return;
    }
    if (L === "abort") {
      u = D, E();
      return;
    }
    if (F) {
      u = D, f.length || (o.length ? O() : E());
      return;
    }
    if (b(), x(), !i.random) {
      const A = i.resources.indexOf(_.resource);
      A !== -1 && A !== i.index && (i.index = A);
    }
    l = "completed", p.forEach((A) => {
      A(D);
    });
  }
  function O() {
    if (l !== "pending")
      return;
    b();
    const _ = o.shift();
    if (_ === void 0) {
      if (f.length) {
        d = setTimeout(() => {
          b(), l === "pending" && (x(), E());
        }, i.timeout);
        return;
      }
      E();
      return;
    }
    const L = {
      status: "pending",
      resource: _,
      callback: (D, F) => {
        $(L, D, F);
      }
    };
    f.push(L), c++, d = setTimeout(O, i.rotate), e(_, t, L.callback);
  }
  return setTimeout(O), S;
}
function _s(i) {
  const t = {
    ...uo,
    ...i
  };
  let e = [];
  function s() {
    e = e.filter((a) => a().status === "pending");
  }
  function n(a, l, c) {
    const u = ho(
      t,
      a,
      l,
      (d, f) => {
        s(), c && c(d, f);
      }
    );
    return e.push(u), u;
  }
  function r(a) {
    return e.find((l) => a(l)) || null;
  }
  return {
    query: n,
    find: r,
    setIndex: (a) => {
      t.index = a;
    },
    getIndex: () => t.index,
    cleanup: s
  };
}
function wi(i) {
  let t;
  if (typeof i.resources == "string")
    t = [i.resources];
  else if (t = i.resources, !(t instanceof Array) || !t.length)
    return null;
  return {
    // API hosts
    resources: t,
    // Root path
    path: i.path || "/",
    // URL length limit
    maxURL: i.maxURL || 500,
    // Timeout before next host is used.
    rotate: i.rotate || 750,
    // Timeout before failing query.
    timeout: i.timeout || 5e3,
    // Randomise default API end point.
    random: i.random === true,
    // Start index
    index: i.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: i.dataAfterTimeout !== false
  };
}
var Ne = /* @__PURE__ */ Object.create(null);
var Yt = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var xe = [];
for (; Yt.length > 0; )
  Yt.length === 1 || Math.random() > 0.5 ? xe.push(Yt.shift()) : xe.push(Yt.pop());
Ne[""] = wi({
  resources: ["https://api.iconify.design"].concat(xe)
});
function _n(i, t) {
  const e = wi(t);
  return e === null ? false : (Ne[i] = e, true);
}
function De(i) {
  return Ne[i];
}
function fo() {
  return Object.keys(Ne);
}
function xn() {
}
var Je = /* @__PURE__ */ Object.create(null);
function po(i) {
  if (!Je[i]) {
    const t = De(i);
    if (!t)
      return;
    const e = _s(t), s = {
      config: t,
      redundancy: e
    };
    Je[i] = s;
  }
  return Je[i];
}
function xs(i, t, e) {
  let s, n;
  if (typeof i == "string") {
    const r = ri(i);
    if (!r)
      return e(void 0, 424), xn;
    n = r.send;
    const o = po(i);
    o && (s = o.redundancy);
  } else {
    const r = wi(i);
    if (r) {
      s = _s(r);
      const o = i.resources ? i.resources[0] : "", a = ri(o);
      a && (n = a.send);
    }
  }
  return !s || !n ? (e(void 0, 424), xn) : s.query(t, n, e)().abort;
}
var wn = "iconify2";
var oe = "iconify";
var ws = oe + "-count";
var $n = oe + "-version";
var $s = 36e5;
var mo = 168;
var bo = 50;
function oi(i, t) {
  try {
    return i.getItem(t);
  } catch {
  }
}
function $i(i, t, e) {
  try {
    return i.setItem(t, e), true;
  } catch {
  }
}
function Cn(i, t) {
  try {
    i.removeItem(t);
  } catch {
  }
}
function li(i, t) {
  return $i(i, ws, t.toString());
}
function ai(i) {
  return parseInt(oi(i, ws)) || 0;
}
var $t = {
  local: true,
  session: true
};
var Cs = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var Ci = false;
function go(i) {
  Ci = i;
}
var ve = typeof window > "u" ? {} : window;
function Es(i) {
  const t = i + "Storage";
  try {
    if (ve && ve[t] && typeof ve[t].length == "number")
      return ve[t];
  } catch {
  }
  $t[i] = false;
}
function Ss(i, t) {
  const e = Es(i);
  if (!e)
    return;
  const s = oi(e, $n);
  if (s !== wn) {
    if (s) {
      const a = ai(e);
      for (let l = 0; l < a; l++)
        Cn(e, oe + l.toString());
    }
    $i(e, $n, wn), li(e, 0);
    return;
  }
  const n = Math.floor(Date.now() / $s) - mo, r = (a) => {
    const l = oe + a.toString(), c = oi(e, l);
    if (typeof c == "string") {
      try {
        const u = JSON.parse(c);
        if (typeof u == "object" && typeof u.cached == "number" && u.cached > n && typeof u.provider == "string" && typeof u.data == "object" && typeof u.data.prefix == "string" && // Valid item: run callback
        t(u, a))
          return true;
      } catch {
      }
      Cn(e, l);
    }
  };
  let o = ai(e);
  for (let a = o - 1; a >= 0; a--)
    r(a) || (a === o - 1 ? (o--, li(e, o)) : Cs[i].add(a));
}
function As() {
  if (!Ci) {
    go(true);
    for (const i in $t)
      Ss(i, (t) => {
        const e = t.data, s = t.provider, n = e.prefix, r = ht(
          s,
          n
        );
        if (!xi(r, e).length)
          return false;
        const o = e.lastModified || -1;
        return r.lastModifiedCached = r.lastModifiedCached ? Math.min(r.lastModifiedCached, o) : o, true;
      });
  }
}
function vo(i, t) {
  const e = i.lastModifiedCached;
  if (
    // Matches or newer
    e && e >= t
  )
    return e === t;
  if (i.lastModifiedCached = t, e)
    for (const s in $t)
      Ss(s, (n) => {
        const r = n.data;
        return n.provider !== i.provider || r.prefix !== i.prefix || r.lastModified === t;
      });
  return true;
}
function yo(i, t) {
  Ci || As();
  function e(s) {
    let n;
    if (!$t[s] || !(n = Es(s)))
      return;
    const r = Cs[s];
    let o;
    if (r.size)
      r.delete(o = Array.from(r).shift());
    else if (o = ai(n), o >= bo || !li(n, o + 1))
      return;
    const a = {
      cached: Math.floor(Date.now() / $s),
      provider: i.provider,
      data: t
    };
    return $i(
      n,
      oe + o.toString(),
      JSON.stringify(a)
    );
  }
  t.lastModified && !vo(i, t.lastModified) || Object.keys(t.icons).length && (t.not_found && (t = Object.assign({}, t), delete t.not_found), e("local") || e("session"));
}
function En() {
}
function _o(i) {
  i.iconsLoaderFlag || (i.iconsLoaderFlag = true, setTimeout(() => {
    i.iconsLoaderFlag = false, oo(i);
  }));
}
function xo(i, t) {
  i.iconsToLoad ? i.iconsToLoad = i.iconsToLoad.concat(t).sort() : i.iconsToLoad = t, i.iconsQueueFlag || (i.iconsQueueFlag = true, setTimeout(() => {
    i.iconsQueueFlag = false;
    const { provider: e, prefix: s } = i, n = i.iconsToLoad;
    delete i.iconsToLoad;
    let r;
    if (!n || !(r = ri(e)))
      return;
    r.prepare(e, s, n).forEach((a) => {
      xs(e, a, (l) => {
        if (typeof l != "object")
          a.icons.forEach((c) => {
            i.missing.add(c);
          });
        else
          try {
            const c = xi(
              i,
              l
            );
            if (!c.length)
              return;
            const u = i.pendingIcons;
            u && c.forEach((d) => {
              u.delete(d);
            }), yo(i, l);
          } catch (c) {
            console.error(c);
          }
        _o(i);
      });
    });
  }));
}
var Ei = (i, t) => {
  const e = co(i, true, gs()), s = ro(e);
  if (!s.pending.length) {
    let l = true;
    return t && setTimeout(() => {
      l && t(
        s.loaded,
        s.missing,
        s.pending,
        En
      );
    }), () => {
      l = false;
    };
  }
  const n = /* @__PURE__ */ Object.create(null), r = [];
  let o, a;
  return s.pending.forEach((l) => {
    const { provider: c, prefix: u } = l;
    if (u === a && c === o)
      return;
    o = c, a = u, r.push(ht(c, u));
    const d = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));
    d[u] || (d[u] = []);
  }), s.pending.forEach((l) => {
    const { provider: c, prefix: u, name: d } = l, f = ht(c, u), p = f.pendingIcons || (f.pendingIcons = /* @__PURE__ */ new Set());
    p.has(d) || (p.add(d), n[c][u].push(d));
  }), r.forEach((l) => {
    const { provider: c, prefix: u } = l;
    n[c][u].length && xo(l, n[c][u]);
  }), t ? ao(t, s, r) : En;
};
var wo = (i) => new Promise((t, e) => {
  const s = typeof i == "string" ? de(i, true) : i;
  if (!s) {
    e(i);
    return;
  }
  Ei([s || i], (n) => {
    if (n.length && s) {
      const r = re(s);
      if (r) {
        t({
          ...he,
          ...r
        });
        return;
      }
    }
    e(i);
  });
});
function $o(i) {
  try {
    const t = typeof i == "string" ? JSON.parse(i) : i;
    if (typeof t.body == "string")
      return {
        ...t
      };
  } catch {
  }
}
function Co(i, t) {
  const e = typeof i == "string" ? de(i, true, true) : null;
  if (!e) {
    const r = $o(i);
    return {
      value: i,
      data: r
    };
  }
  const s = re(e);
  if (s !== void 0 || !e.prefix)
    return {
      value: i,
      name: e,
      data: s
      // could be 'null' -> icon is missing
    };
  const n = Ei([e], () => t(i, e, re(e)));
  return {
    value: i,
    name: e,
    loading: n
  };
}
function Ze(i) {
  return i.hasAttribute("inline");
}
var Os = false;
try {
  Os = navigator.vendor.indexOf("Apple") === 0;
} catch {
}
function Eo(i, t) {
  switch (t) {
    case "svg":
    case "bg":
    case "mask":
      return t;
  }
  return t !== "style" && (Os || i.indexOf("<a") === -1) ? "svg" : i.indexOf("currentColor") === -1 ? "bg" : "mask";
}
var So = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var Ao = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function ci(i, t, e) {
  if (t === 1)
    return i;
  if (e = e || 100, typeof i == "number")
    return Math.ceil(i * t * e) / e;
  if (typeof i != "string")
    return i;
  const s = i.split(So);
  if (s === null || !s.length)
    return i;
  const n = [];
  let r = s.shift(), o = Ao.test(r);
  for (; ; ) {
    if (o) {
      const a = parseFloat(r);
      isNaN(a) ? n.push(r) : n.push(Math.ceil(a * t * e) / e);
    } else
      n.push(r);
    if (r = s.shift(), r === void 0)
      return n.join("");
    o = !o;
  }
}
function Oo(i, t = "defs") {
  let e = "";
  const s = i.indexOf("<" + t);
  for (; s >= 0; ) {
    const n = i.indexOf(">", s), r = i.indexOf("</" + t);
    if (n === -1 || r === -1)
      break;
    const o = i.indexOf(">", r);
    if (o === -1)
      break;
    e += i.slice(n + 1, r).trim(), i = i.slice(0, s).trim() + i.slice(o + 1);
  }
  return {
    defs: e,
    content: i
  };
}
function ko(i, t) {
  return i ? "<defs>" + i + "</defs>" + t : t;
}
function Po(i, t, e) {
  const s = Oo(i);
  return ko(s.defs, t + s.content + e);
}
var To = (i) => i === "unset" || i === "undefined" || i === "none";
function ks(i, t) {
  const e = {
    ...he,
    ...i
  }, s = {
    ...fs,
    ...t
  }, n = {
    left: e.left,
    top: e.top,
    width: e.width,
    height: e.height
  };
  let r = e.body;
  [e, s].forEach((v) => {
    const g = [], S = v.hFlip, E = v.vFlip;
    let x = v.rotate;
    S ? E ? x += 2 : (g.push(
      "translate(" + (n.width + n.left).toString() + " " + (0 - n.top).toString() + ")"
    ), g.push("scale(-1 1)"), n.top = n.left = 0) : E && (g.push(
      "translate(" + (0 - n.left).toString() + " " + (n.height + n.top).toString() + ")"
    ), g.push("scale(1 -1)"), n.top = n.left = 0);
    let $;
    switch (x < 0 && (x -= Math.floor(x / 4) * 4), x = x % 4, x) {
      case 1:
        $ = n.height / 2 + n.top, g.unshift(
          "rotate(90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
      case 2:
        g.unshift(
          "rotate(180 " + (n.width / 2 + n.left).toString() + " " + (n.height / 2 + n.top).toString() + ")"
        );
        break;
      case 3:
        $ = n.width / 2 + n.left, g.unshift(
          "rotate(-90 " + $.toString() + " " + $.toString() + ")"
        );
        break;
    }
    x % 2 === 1 && (n.left !== n.top && ($ = n.left, n.left = n.top, n.top = $), n.width !== n.height && ($ = n.width, n.width = n.height, n.height = $)), g.length && (r = Po(
      r,
      '<g transform="' + g.join(" ") + '">',
      "</g>"
    ));
  });
  const o = s.width, a = s.height, l = n.width, c = n.height;
  let u, d;
  o === null ? (d = a === null ? "1em" : a === "auto" ? c : a, u = ci(d, l / c)) : (u = o === "auto" ? l : o, d = a === null ? ci(u, c / l) : a === "auto" ? c : a);
  const f = {}, p = (v, g) => {
    To(g) || (f[v] = g.toString());
  };
  p("width", u), p("height", d);
  const b = [n.left, n.top, l, c];
  return f.viewBox = b.join(" "), {
    attributes: f,
    viewBox: b,
    body: r
  };
}
function Si(i, t) {
  let e = i.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const s in t)
    e += " " + s + '="' + t[s] + '"';
  return '<svg xmlns="http://www.w3.org/2000/svg"' + e + ">" + i + "</svg>";
}
function Lo(i) {
  return i.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function Io(i) {
  return "data:image/svg+xml," + Lo(i);
}
function Ps(i) {
  return 'url("' + Io(i) + '")';
}
var Ro = () => {
  let i;
  try {
    if (i = fetch, typeof i == "function")
      return i;
  } catch {
  }
};
var ke = Ro();
function zo(i) {
  ke = i;
}
function Mo() {
  return ke;
}
function jo(i, t) {
  const e = De(i);
  if (!e)
    return 0;
  let s;
  if (!e.maxURL)
    s = 0;
  else {
    let n = 0;
    e.resources.forEach((o) => {
      n = Math.max(n, o.length);
    });
    const r = t + ".json?icons=";
    s = e.maxURL - n - e.path.length - r.length;
  }
  return s;
}
function Bo(i) {
  return i === 404;
}
var Ho = (i, t, e) => {
  const s = [], n = jo(i, t), r = "icons";
  let o = {
    type: r,
    provider: i,
    prefix: t,
    icons: []
  }, a = 0;
  return e.forEach((l, c) => {
    a += l.length + 1, a >= n && c > 0 && (s.push(o), o = {
      type: r,
      provider: i,
      prefix: t,
      icons: []
    }, a = l.length), o.icons.push(l);
  }), s.push(o), s;
};
function No(i) {
  if (typeof i == "string") {
    const t = De(i);
    if (t)
      return t.path;
  }
  return "/";
}
var Do = (i, t, e) => {
  if (!ke) {
    e("abort", 424);
    return;
  }
  let s = No(t.provider);
  switch (t.type) {
    case "icons": {
      const r = t.prefix, a = t.icons.join(","), l = new URLSearchParams({
        icons: a
      });
      s += r + ".json?" + l.toString();
      break;
    }
    case "custom": {
      const r = t.uri;
      s += r.slice(0, 1) === "/" ? r.slice(1) : r;
      break;
    }
    default:
      e("abort", 400);
      return;
  }
  let n = 503;
  ke(i + s).then((r) => {
    const o = r.status;
    if (o !== 200) {
      setTimeout(() => {
        e(Bo(o) ? "abort" : "next", o);
      });
      return;
    }
    return n = 501, r.json();
  }).then((r) => {
    if (typeof r != "object" || r === null) {
      setTimeout(() => {
        r === 404 ? e("abort", r) : e("next", n);
      });
      return;
    }
    setTimeout(() => {
      e("success", r);
    });
  }).catch(() => {
    e("next", n);
  });
};
var Fo = {
  prepare: Ho,
  send: Do
};
function Sn(i, t) {
  switch (i) {
    case "local":
    case "session":
      $t[i] = t;
      break;
    case "all":
      for (const e in $t)
        $t[e] = t;
      break;
  }
}
var ti = "data-style";
var Ts = "";
function Vo(i) {
  Ts = i;
}
function An(i, t) {
  let e = Array.from(i.childNodes).find((s) => s.hasAttribute && s.hasAttribute(ti));
  e || (e = document.createElement("style"), e.setAttribute(ti, ti), i.appendChild(e)), e.textContent = ":host{display:inline-block;vertical-align:" + (t ? "-0.125em" : "0") + "}span,svg{display:block}" + Ts;
}
function Ls() {
  yn("", Fo), gs(true);
  let i;
  try {
    i = window;
  } catch {
  }
  if (i) {
    if (As(), i.IconifyPreload !== void 0) {
      const e = i.IconifyPreload, s = "Invalid IconifyPreload syntax.";
      typeof e == "object" && e !== null && (e instanceof Array ? e : [e]).forEach((n) => {
        try {
          (typeof n != "object" || n === null || n instanceof Array || // Check for 'icons' and 'prefix'
          typeof n.icons != "object" || typeof n.prefix != "string" || // Add icon set
          !gn(n)) && console.error(s);
        } catch {
          console.error(s);
        }
      });
    }
    if (i.IconifyProviders !== void 0) {
      const e = i.IconifyProviders;
      if (typeof e == "object" && e !== null)
        for (const s in e) {
          const n = "IconifyProviders[" + s + "] is invalid.";
          try {
            const r = e[s];
            if (typeof r != "object" || !r || r.resources === void 0)
              continue;
            _n(s, r) || console.error(n);
          } catch {
            console.error(n);
          }
        }
    }
  }
  return {
    enableCache: (e) => Sn(e, true),
    disableCache: (e) => Sn(e, false),
    iconLoaded: vn,
    iconExists: vn,
    getIcon: so,
    listIcons: no,
    addIcon: vs,
    addCollection: gn,
    calculateSize: ci,
    buildIcon: ks,
    iconToHTML: Si,
    svgToURL: Ps,
    loadIcons: Ei,
    loadIcon: wo,
    addAPIProvider: _n,
    appendCustomStyle: Vo,
    _api: {
      getAPIConfig: De,
      setAPIModule: yn,
      sendAPIQuery: xs,
      setFetch: zo,
      getFetch: Mo,
      listAPIProviders: fo
    }
  };
}
var ui = {
  "background-color": "currentColor"
};
var Is = {
  "background-color": "transparent"
};
var On = {
  image: "var(--svg)",
  repeat: "no-repeat",
  size: "100% 100%"
};
var kn = {
  "-webkit-mask": ui,
  mask: ui,
  background: Is
};
for (const i in kn) {
  const t = kn[i];
  for (const e in On)
    t[i + "-" + e] = On[e];
}
function Pn(i) {
  return i ? i + (i.match(/^[-0-9.]+$/) ? "px" : "") : "inherit";
}
function Uo(i, t, e) {
  const s = document.createElement("span");
  let n = i.body;
  n.indexOf("<a") !== -1 && (n += "<!-- " + Date.now() + " -->");
  const r = i.attributes, o = Si(n, {
    ...r,
    width: t.width + "",
    height: t.height + ""
  }), a = Ps(o), l = s.style, c = {
    "--svg": a,
    width: Pn(r.width),
    height: Pn(r.height),
    ...e ? ui : Is
  };
  for (const u in c)
    l.setProperty(u, c[u]);
  return s;
}
var Zt;
function qo() {
  try {
    Zt = window.trustedTypes.createPolicy("iconify", {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      createHTML: (i) => i
    });
  } catch {
    Zt = null;
  }
}
function Wo(i) {
  return Zt === void 0 && qo(), Zt ? Zt.createHTML(i) : i;
}
function Qo(i) {
  const t = document.createElement("span"), e = i.attributes;
  let s = "";
  e.width || (s = "width: inherit;"), e.height || (s += "height: inherit;"), s && (e.style = s);
  const n = Si(i.body, e);
  return t.innerHTML = Wo(n), t.firstChild;
}
function hi(i) {
  return Array.from(i.childNodes).find((t) => {
    const e = t.tagName && t.tagName.toUpperCase();
    return e === "SPAN" || e === "SVG";
  });
}
function Tn(i, t) {
  const e = t.icon.data, s = t.customisations, n = ks(e, s);
  s.preserveAspectRatio && (n.attributes.preserveAspectRatio = s.preserveAspectRatio);
  const r = t.renderedMode;
  let o;
  switch (r) {
    case "svg":
      o = Qo(n);
      break;
    default:
      o = Uo(n, {
        ...he,
        ...e
      }, r === "mask");
  }
  const a = hi(i);
  a ? o.tagName === "SPAN" && a.tagName === o.tagName ? a.setAttribute("style", o.getAttribute("style")) : i.replaceChild(o, a) : i.appendChild(o);
}
function Ln(i, t, e) {
  const s = e && (e.rendered ? e : e.lastRender);
  return {
    rendered: false,
    inline: t,
    icon: i,
    lastRender: s
  };
}
function Yo(i = "iconify-icon") {
  let t, e;
  try {
    t = window.customElements, e = window.HTMLElement;
  } catch {
    return;
  }
  if (!t || !e)
    return;
  const s = t.get(i);
  if (s)
    return s;
  const n = [
    // Icon
    "icon",
    // Mode
    "mode",
    "inline",
    "observe",
    // Customisations
    "width",
    "height",
    "rotate",
    "flip"
  ], r = class extends e {
    /**
     * Constructor
     */
    constructor() {
      super();
      ot(this, "_shadowRoot");
      ot(this, "_initialised", false);
      ot(this, "_state");
      ot(this, "_checkQueued", false);
      ot(this, "_connected", false);
      ot(this, "_observer", null);
      ot(this, "_visible", true);
      const l = this._shadowRoot = this.attachShadow({
        mode: "open"
      }), c = Ze(this);
      An(l, c), this._state = Ln({
        value: ""
      }, c), this._queueCheck();
    }
    /**
     * Connected to DOM
     */
    connectedCallback() {
      this._connected = true, this.startObserver();
    }
    /**
     * Disconnected from DOM
     */
    disconnectedCallback() {
      this._connected = false, this.stopObserver();
    }
    /**
     * Observed attributes
     */
    static get observedAttributes() {
      return n.slice(0);
    }
    /**
     * Observed properties that are different from attributes
     *
     * Experimental! Need to test with various frameworks that support it
     */
    /*
    static get properties() {
        return {
            inline: {
                type: Boolean,
                reflect: true,
            },
            // Not listing other attributes because they are strings or combination
            // of string and another type. Cannot have multiple types
        };
    }
    */
    /**
     * Attribute has changed
     */
    attributeChangedCallback(l) {
      switch (l) {
        case "inline": {
          const c = Ze(this), u = this._state;
          c !== u.inline && (u.inline = c, An(this._shadowRoot, c));
          break;
        }
        case "observer": {
          this.observer ? this.startObserver() : this.stopObserver();
          break;
        }
        default:
          this._queueCheck();
      }
    }
    /**
     * Get/set icon
     */
    get icon() {
      const l = this.getAttribute("icon");
      if (l && l.slice(0, 1) === "{")
        try {
          return JSON.parse(l);
        } catch {
        }
      return l;
    }
    set icon(l) {
      typeof l == "object" && (l = JSON.stringify(l)), this.setAttribute("icon", l);
    }
    /**
     * Get/set inline
     */
    get inline() {
      return Ze(this);
    }
    set inline(l) {
      l ? this.setAttribute("inline", "true") : this.removeAttribute("inline");
    }
    /**
     * Get/set observer
     */
    get observer() {
      return this.hasAttribute("observer");
    }
    set observer(l) {
      l ? this.setAttribute("observer", "true") : this.removeAttribute("observer");
    }
    /**
     * Restart animation
     */
    restartAnimation() {
      const l = this._state;
      if (l.rendered) {
        const c = this._shadowRoot;
        if (l.renderedMode === "svg")
          try {
            c.lastChild.setCurrentTime(0);
            return;
          } catch {
          }
        Tn(c, l);
      }
    }
    /**
     * Get status
     */
    get status() {
      const l = this._state;
      return l.rendered ? "rendered" : l.icon.data === null ? "failed" : "loading";
    }
    /**
     * Queue attributes re-check
     */
    _queueCheck() {
      this._checkQueued || (this._checkQueued = true, setTimeout(() => {
        this._check();
      }));
    }
    /**
     * Check for changes
     */
    _check() {
      if (!this._checkQueued)
        return;
      this._checkQueued = false;
      const l = this._state, c = this.getAttribute("icon");
      if (c !== l.icon.value) {
        this._iconChanged(c);
        return;
      }
      if (!l.rendered || !this._visible)
        return;
      const u = this.getAttribute("mode"), d = mn(this);
      (l.attrMode !== u || Kr(l.customisations, d) || !hi(this._shadowRoot)) && this._renderIcon(l.icon, d, u);
    }
    /**
     * Icon value has changed
     */
    _iconChanged(l) {
      const c = Co(l, (u, d, f) => {
        const p = this._state;
        if (p.rendered || this.getAttribute("icon") !== u)
          return;
        const b = {
          value: u,
          name: d,
          data: f
        };
        b.data ? this._gotIconData(b) : p.icon = b;
      });
      c.data ? this._gotIconData(c) : this._state = Ln(c, this._state.inline, this._state);
    }
    /**
     * Force render icon on state change
     */
    _forceRender() {
      if (!this._visible) {
        const l = hi(this._shadowRoot);
        l && this._shadowRoot.removeChild(l);
        return;
      }
      this._queueCheck();
    }
    /**
     * Got new icon data, icon is ready to (re)render
     */
    _gotIconData(l) {
      this._checkQueued = false, this._renderIcon(l, mn(this), this.getAttribute("mode"));
    }
    /**
     * Re-render based on icon data
     */
    _renderIcon(l, c, u) {
      const d = Eo(l.data.body, u), f = this._state.inline;
      Tn(this._shadowRoot, this._state = {
        rendered: true,
        icon: l,
        inline: f,
        customisations: c,
        attrMode: u,
        renderedMode: d
      });
    }
    /**
     * Start observer
     */
    startObserver() {
      if (!this._observer)
        try {
          this._observer = new IntersectionObserver((l) => {
            const c = l.some((u) => u.isIntersecting);
            c !== this._visible && (this._visible = c, this._forceRender());
          }), this._observer.observe(this);
        } catch {
          if (this._observer) {
            try {
              this._observer.disconnect();
            } catch {
            }
            this._observer = null;
          }
        }
    }
    /**
     * Stop observer
     */
    stopObserver() {
      this._observer && (this._observer.disconnect(), this._observer = null, this._visible = true, this._connected && this._forceRender());
    }
  };
  n.forEach((a) => {
    a in r.prototype || Object.defineProperty(r.prototype, a, {
      get: function() {
        return this.getAttribute(a);
      },
      set: function(l) {
        l !== null ? this.setAttribute(a, l) : this.removeAttribute(a);
      }
    });
  });
  const o = Ls();
  for (const a in o)
    r[a] = r.prototype[a] = o[a];
  return t.define(i, r), r;
}
Yo() || Ls();
var Go = Object.defineProperty;
var Ko = Object.getOwnPropertyDescriptor;
var U = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Ko(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Go(t, e, n), n;
};
var ki = class ki2 extends w {
  constructor() {
    super(), this.labelHidden = false, this.active = false, this.disabled = false, this.vertical = false, this.tooltipVisible = false, this._stateBeforeLoading = {
      disabled: false,
      icon: ""
    }, this._loading = false, this._parent = Bt(), this._tooltip = Bt(), this._mouseLeave = false, this.onClick = (t) => {
      t.stopPropagation(), this.disabled || this.dispatchEvent(new Event("click"));
    }, this.showContextMenu = () => {
      const t = this._contextMenu;
      t && (t.visible = true);
    }, this.mouseLeave = true;
  }
  set loading(t) {
    if (this._loading = t, t)
      this._stateBeforeLoading = {
        disabled: this.disabled,
        icon: this.icon
      }, this.disabled = t, this.icon = "eos-icons:loading";
    else {
      const { disabled: e, icon: s } = this._stateBeforeLoading;
      this.disabled = e, this.icon = s;
    }
  }
  get loading() {
    return this._loading;
  }
  set mouseLeave(t) {
    this._mouseLeave = t, t && (this.tooltipVisible = false, clearTimeout(this.timeoutID));
  }
  get mouseLeave() {
    return this._mouseLeave;
  }
  computeTooltipPosition() {
    const { value: t } = this._parent, { value: e } = this._tooltip;
    t && e && is(t, e, {
      placement: "bottom",
      middleware: [Vn(10), es(), ts(), Zn({ padding: 5 })]
    }).then((s) => {
      const { x: n, y: r } = s;
      Object.assign(e.style, {
        left: `${n}px`,
        top: `${r}px`
      });
    });
  }
  onMouseEnter() {
    if (!(this.tooltipTitle || this.tooltipText))
      return;
    this.mouseLeave = false;
    const t = this.tooltipTime ?? 700;
    this.timeoutID = setTimeout(() => {
      this.mouseLeave || (this.computeTooltipPosition(), this.tooltipVisible = true);
    }, t);
  }
  click() {
    this.disabled || super.click();
  }
  get _contextMenu() {
    return this.querySelector("bim-context-menu");
  }
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("click", this.showContextMenu);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.removeEventListener("click", this.showContextMenu);
  }
  render() {
    const t = m`
      <div ${Ht(this._tooltip)} class="tooltip">
        ${this.tooltipTitle ? m`<p style="text-wrap: nowrap;">
              <strong>${this.tooltipTitle}</strong>
            </p>` : null}
        ${this.tooltipText ? m`<p style="width: 9rem;">${this.tooltipText}</p>` : null}
      </div>
    `;
    return m`
      <div ${Ht(this._parent)} class="parent" @click=${this.onClick}>
        ${this.label || this.icon ? m`
              <div
                class="button"
                @mouseenter=${this.onMouseEnter}
                @mouseleave=${() => this.mouseLeave = true}
              >
                <bim-label
                  .icon=${this.icon}
                  .vertical=${this.vertical}
                  .labelHidden=${this.labelHidden}
                  >${this.label}</bim-label
                >
              </div>
            ` : null}
        ${this.tooltipTitle || this.tooltipText ? t : null}
      </div>
      <slot></slot>
    `;
  }
};
ki.styles = C`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100, white);
      display: block;
      flex: 1;
      pointer-events: none;
      background-color: var(--bim-button--bgc, var(--bim-ui_bg-contrast-20));
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:not([disabled]):hover) {
      cursor: pointer;
    }

    bim-label {
      pointer-events: none;
    }

    .parent {
      --bim-icon--c: var(--bim-label--c);
      position: relative;
      display: flex;
      height: 100%;
      user-select: none;
      row-gap: 0.125rem;
      min-height: var(--bim-ui_size-5xl);
      min-width: var(--bim-ui_size-5xl);
    }

    .button,
    .children {
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
    }

    .children {
      padding: 0 0.375rem;
      position: absolute;
      height: 100%;
      right: 0;
    }

    :host(:not([label-hidden])[icon][vertical]) .parent {
      min-height: 2.5rem;
    }

    .button {
      flex-grow: 1;
    }

    :host(:not([label-hidden])[label]) .button {
      justify-content: var(--bim-button--jc, center);
    }

    :host(:hover),
    :host([active]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }

    :host(:not([label]):not([icon])) .children {
      flex: 1;
    }

    :host([vertical]) .parent {
      justify-content: center;
    }

    :host(:not([label-hidden])[label]) .button {
      padding: 0 0.5rem;
    }

    :host([disabled]) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
      background-color: gray;
    }

    ::slotted(bim-button) {
      --bim-icon--fz: var(--bim-ui_size-base);
      --bim-button--bdrs: var(--bim-ui_size-4xs);
      --bim-button--olw: 0;
      --bim-button--olc: transparent;
    }

    .tooltip {
      position: absolute;
      padding: 0.75rem;
      z-index: 99;
      display: flex;
      flex-flow: column;
      row-gap: 0.375rem;
      box-shadow: 0 0 10px 3px rgba(0 0 0 / 20%);
      outline: 1px solid var(--bim-ui_bg-contrast-40);
      font-size: var(--bim-ui_size-xs);
      border-radius: var(--bim-ui_size-4xs);
      background-color: var(--bim-ui_bg-contrast-20);
      color: var(--bim-ui_bg-contrast-100);
    }

    .tooltip p {
      margin: 0;
      padding: 0;
    }

    :host(:not([tooltip-visible])) .tooltip {
      display: none;
    }
  `;
var z = ki;
U([
  h({ type: String, reflect: true })
], z.prototype, "label", 2);
U([
  h({ type: Boolean, attribute: "label-hidden", reflect: true })
], z.prototype, "labelHidden", 2);
U([
  h({ type: Boolean, reflect: true })
], z.prototype, "active", 2);
U([
  h({ type: Boolean, reflect: true, attribute: "disabled" })
], z.prototype, "disabled", 2);
U([
  h({ type: String, reflect: true })
], z.prototype, "icon", 2);
U([
  h({ type: Boolean, reflect: true })
], z.prototype, "vertical", 2);
U([
  h({ type: Number, attribute: "tooltip-time", reflect: true })
], z.prototype, "tooltipTime", 2);
U([
  h({ type: Boolean, attribute: "tooltip-visible", reflect: true })
], z.prototype, "tooltipVisible", 2);
U([
  h({ type: String, attribute: "tooltip-title", reflect: true })
], z.prototype, "tooltipTitle", 2);
U([
  h({ type: String, attribute: "tooltip-text", reflect: true })
], z.prototype, "tooltipText", 2);
U([
  h({ type: Boolean, reflect: true })
], z.prototype, "loading", 1);
var Xo = Object.defineProperty;
var fe = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Xo(t, e, n), n;
};
var Pi = class Pi2 extends w {
  constructor() {
    super(...arguments), this.checked = false, this.inverted = false, this.onValueChange = new Event("change");
  }
  /**
   * A getter that returns the current checked state of the checkbox. This is useful for retrieving the checkbox's value in form submissions or JavaScript interactions as it provides a consistent `value` property as many other components.
   * @type {boolean}
   * @default false
   * @example <script>console.log(document.querySelector('bim-checkbox').value);<\/script>
   * @example
   * const checkbox = document.createElement('bim-checkbox');
   * document.body.appendChild(checkbox);
   * console.log(checkbox.value); // false initially
   */
  get value() {
    return this.checked;
  }
  onChange(t) {
    t.stopPropagation(), this.checked = t.target.checked, this.dispatchEvent(this.onValueChange);
  }
  render() {
    return m`
      <div class="parent">
        ${this.label ? m`<bim-label .icon="${this.icon}">${this.label}</bim-label> ` : null}
        <input
          type="checkbox"
          aria-label=${this.label || this.name || "Checkbox Input"}
          @change="${this.onChange}"
          .checked="${this.checked}"
        />
      </div>
    `;
  }
};
Pi.styles = C`
    :host {
      display: block;
    }

    .parent {
      display: flex;
      justify-content: space-between;
      height: 1.75rem;
      column-gap: 0.25rem;
      width: 100%;
      align-items: center;
      transition: all 0.15s;
    }

    :host([inverted]) .parent {
      flex-direction: row-reverse;
      justify-content: start;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
      transition: all 0.15s;
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }
  `;
var dt = Pi;
fe([
  h({ type: String, reflect: true })
], dt.prototype, "icon");
fe([
  h({ type: String, reflect: true })
], dt.prototype, "name");
fe([
  h({ type: String, reflect: true })
], dt.prototype, "label");
fe([
  h({ type: Boolean, reflect: true })
], dt.prototype, "checked");
fe([
  h({ type: Boolean, reflect: true })
], dt.prototype, "inverted");
var Jo = Object.defineProperty;
var Vt = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Jo(t, e, n), n;
};
var Ti = class Ti2 extends w {
  constructor() {
    super(...arguments), this.vertical = false, this.color = "#bcf124", this._colorInput = Bt(), this._textInput = Bt(), this.onValueChange = new Event("input"), this.onOpacityInput = (t) => {
      const e = t.target;
      this.opacity = e.value, this.dispatchEvent(this.onValueChange);
    };
  }
  /**
   * Represents both the color and opacity values combined into a single object. This is an instance property, not an HTMLElement attribute.
   * @type {Object}
   * @example
   * const colorInput = document.createElement('bim-color-input');
   * colorInput.value = { color: '#ff0000', opacity: 0.5 };
   */
  set value(t) {
    const { color: e, opacity: s } = t;
    this.color = e, s && (this.opacity = s);
  }
  get value() {
    const t = {
      color: this.color
    };
    return this.opacity && (t.opacity = this.opacity), t;
  }
  onColorInput(t) {
    t.stopPropagation();
    const { value: e } = this._colorInput;
    e && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  onTextInput(t) {
    t.stopPropagation();
    const { value: e } = this._textInput;
    if (!e)
      return;
    const { value: s } = e;
    let n = s.replace(/[^a-fA-F0-9]/g, "");
    n.startsWith("#") || (n = `#${n}`), e.value = n.slice(0, 7), e.value.length === 7 && (this.color = e.value, this.dispatchEvent(this.onValueChange));
  }
  /**
   * Focuses on the color input by programmatically triggering a click event on the underlying color input element.
   * If the color input element is not available, the function does nothing.
   */
  focus() {
    const { value: t } = this._colorInput;
    t && t.click();
  }
  render() {
    return m`
      <div class="parent">
        <bim-input
          .label=${this.label}
          .icon=${this.icon}
          .vertical="${this.vertical}"
        >
          <div class="color-container">
            <div
              style="display: flex; align-items: center; gap: .375rem; height: 100%; flex: 1; padding: 0 0.5rem;"
            >
              <input
                ${Ht(this._colorInput)}
                @input="${this.onColorInput}"
                type="color"
                aria-label=${this.label || this.name || "Color Input"}
                value="${this.color}"
              />
              <div
                @click=${this.focus}
                class="sample"
                style="background-color: ${this.color}"
              ></div>
              <input
                ${Ht(this._textInput)}
                @input="${this.onTextInput}"
                value="${this.color}"
                type="text"
                aria-label=${this.label || this.name || "Text Color Input"}
              />
            </div>
            ${this.opacity !== void 0 ? m`<bim-number-input
                  @change=${this.onOpacityInput}
                  slider
                  suffix="%"
                  min="0"
                  value=${this.opacity}
                  max="100"
                ></bim-number-input>` : null}
          </div>
        </bim-input>
      </div>
    `;
  }
};
Ti.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-ui_accent-base);
    }

    .parent {
      display: flex;
      gap: 0.375rem;
    }

    .color-container {
      position: relative;
      outline: none;
      display: flex;
      height: 100%;
      gap: 0.5rem;
      justify-content: flex-start;
      align-items: center;
      flex: 1;
      border-radius: var(--bim-color-input--bdrs, var(--bim-ui_size-4xs));
    }

    .color-container input[type="color"] {
      position: absolute;
      bottom: -0.25rem;
      visibility: hidden;
      width: 0;
      height: 0;
    }

    .color-container .sample {
      width: 1rem;
      height: 1rem;
      border-radius: 0.125rem;
      background-color: #fff;
    }

    .color-container input[type="text"] {
      height: 100%;
      flex: 1;
      width: 3.25rem;
      text-transform: uppercase;
      font-size: 0.75rem;
      background-color: transparent;
      padding: 0%;
      outline: none;
      border: none;
      color: var(--bim-color-input--c, var(--bim-ui_bg-contrast-100));
    }

    bim-number-input {
      flex-grow: 0;
    }
  `;
var J = Ti;
Vt([
  h({ type: String, reflect: true })
], J.prototype, "name");
Vt([
  h({ type: String, reflect: true })
], J.prototype, "label");
Vt([
  h({ type: String, reflect: true })
], J.prototype, "icon");
Vt([
  h({ type: Boolean, reflect: true })
], J.prototype, "vertical");
Vt([
  h({ type: Number, reflect: true })
], J.prototype, "opacity");
Vt([
  h({ type: String, reflect: true })
], J.prototype, "color");
var Zo = C`
  ::-webkit-scrollbar {
    width: 0.4rem;
    height: 0.4rem;
    overflow: hidden;
  }

  ::-webkit-scrollbar-thumb {
    border-radius: 0.25rem;
    background-color: var(
      --bim-scrollbar--c,
      color-mix(in lab, var(--bim-ui_main-base), white 15%)
    );
  }

  ::-webkit-scrollbar-track {
    background-color: var(--bim-scrollbar--bgc, var(--bim-ui_bg-base));
  }
`;
var tl = C`
  :root {
    /* Grayscale Colors */
    --bim-ui_gray-0: hsl(210 10% 5%);
    --bim-ui_gray-1: hsl(210 10% 10%);
    --bim-ui_gray-2: hsl(210 10% 20%);
    --bim-ui_gray-3: hsl(210 10% 30%);
    --bim-ui_gray-4: hsl(210 10% 40%);
    --bim-ui_gray-6: hsl(210 10% 60%);
    --bim-ui_gray-7: hsl(210 10% 70%);
    --bim-ui_gray-8: hsl(210 10% 80%);
    --bim-ui_gray-9: hsl(210 10% 90%);
    --bim-ui_gray-10: hsl(210 10% 95%);

    /* Brand Colors */
    --bim-ui_main-base: #6528d7;
    --bim-ui_accent-base: #bcf124;

    /* Brand Colors Contrasts */
    --bim-ui_main-contrast: var(--bim-ui_gray-10);
    --bim-ui_accent-contrast: var(--bim-ui_gray-0);

    /* Sizes */
    --bim-ui_size-4xs: 0.375rem;
    --bim-ui_size-3xs: 0.5rem;
    --bim-ui_size-2xs: 0.625rem;
    --bim-ui_size-xs: 0.75rem;
    --bim-ui_size-sm: 0.875rem;
    --bim-ui_size-base: 1rem;
    --bim-ui_size-lg: 1.125rem;
    --bim-ui_size-xl: 1.25rem;
    --bim-ui_size-2xl: 1.375rem;
    --bim-ui_size-3xl: 1.5rem;
    --bim-ui_size-4xl: 1.625rem;
    --bim-ui_size-5xl: 1.75rem;
    --bim-ui_size-6xl: 1.875rem;
    --bim-ui_size-7xl: 2rem;
    --bim-ui_size-8xl: 2.125rem;
    --bim-ui_size-9xl: 2.25rem;
  }

  /* Background Colors */
  @media (prefers-color-scheme: dark) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-0);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
    }
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bim-ui_bg-base: var(--bim-ui_gray-10);
      --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
      --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
      --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
      --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
      --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
      --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
      --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
      --bim-ui_accent-base: #6528d7;
    }
  }

  html.bim-ui-dark {
    --bim-ui_bg-base: var(--bim-ui_gray-0);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-1);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-3);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-10);
  }

  html.bim-ui-light {
    --bim-ui_bg-base: var(--bim-ui_gray-10);
    --bim-ui_bg-contrast-10: var(--bim-ui_gray-9);
    --bim-ui_bg-contrast-20: var(--bim-ui_gray-8);
    --bim-ui_bg-contrast-30: var(--bim-ui_gray-7);
    --bim-ui_bg-contrast-40: var(--bim-ui_gray-6);
    --bim-ui_bg-contrast-60: var(--bim-ui_gray-4);
    --bim-ui_bg-contrast-80: var(--bim-ui_gray-2);
    --bim-ui_bg-contrast-100: var(--bim-ui_gray-0);
    --bim-ui_accent-base: #6528d7;
  }

  [data-context-dialog]::backdrop {
    background-color: transparent;
  }
`;
var vt = {
  scrollbar: Zo,
  globalStyles: tl
};
var y = class y2 {
  static set config(t) {
    this._config = { ...y2._config, ...t };
  }
  static get config() {
    return y2._config;
  }
  static addGlobalStyles() {
    let t = document.querySelector("style[id='bim-ui']");
    if (t)
      return;
    t = document.createElement("style"), t.id = "bim-ui", t.textContent = vt.globalStyles.cssText;
    const e = document.head.firstChild;
    e ? document.head.insertBefore(t, e) : document.head.append(t);
  }
  static defineCustomElement(t, e) {
    customElements.get(t) || customElements.define(t, e);
  }
  /**
   * @deprecated Use `Manager.init()` instead.
   */
  static registerComponents() {
    y2.init();
  }
  /**
   * Initializes the BIM UI library by defining custom elements.
   * It ensures that all necessary styles and custom elements are registered for use in BIM UI components.
   *
   * @example
   * ```typescript
   * import { Manager } from "@thatopen/ui";
   * Manager.init();
   * ```
   */
  static init() {
    y2.addGlobalStyles(), y2.defineCustomElement("bim-button", z), y2.defineCustomElement("bim-checkbox", dt), y2.defineCustomElement("bim-color-input", J), y2.defineCustomElement("bim-context-menu", nl), y2.defineCustomElement("bim-dropdown", V), y2.defineCustomElement("bim-grid", le), y2.defineCustomElement("bim-icon", pi), y2.defineCustomElement("bim-input", At), y2.defineCustomElement("bim-label", ft), y2.defineCustomElement("bim-number-input", I), y2.defineCustomElement("bim-option", T), y2.defineCustomElement("bim-panel", Z), y2.defineCustomElement("bim-panel-section", pt), y2.defineCustomElement("bim-selector", mt), y2.defineCustomElement("bim-table", M), y2.defineCustomElement("bim-tabs", et), y2.defineCustomElement("bim-tab", R), y2.defineCustomElement("bim-table-cell", Te), y2.defineCustomElement("bim-table-children", Le), y2.defineCustomElement("bim-table-group", Ie), y2.defineCustomElement("bim-table-row", tt), y2.defineCustomElement("bim-text-input", H), y2.defineCustomElement("bim-toolbar", Dt), y2.defineCustomElement("bim-toolbar-group", Nt), y2.defineCustomElement(
      "bim-toolbar-section",
      bt
    ), y2.defineCustomElement("bim-viewport", Re);
  }
  static newRandomId() {
    const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let e = "";
    for (let s = 0; s < 10; s++) {
      const n = Math.floor(Math.random() * t.length);
      e += t.charAt(n);
    }
    return e;
  }
};
y._config = {
  sectionLabelOnVerticalToolbar: false
  // draggableToolbars: true,
  // draggablePanels: true,
};
var di = y;
var Rs = class extends w {
  constructor() {
    super(...arguments), this._lazyLoadObserver = null, this._visibleElements = [], this.ELEMENTS_BEFORE_OBSERVER = 20, this.useObserver = false, this.elements = /* @__PURE__ */ new Set(), this.observe = (t) => {
      if (!this.useObserver)
        return;
      for (const s of t)
        this.elements.add(s);
      const e = t.slice(this.ELEMENTS_BEFORE_OBSERVER);
      for (const s of e)
        s.remove();
      this.observeLastElement();
    };
  }
  set visibleElements(t) {
    this._visibleElements = this.useObserver ? t : [], this.requestUpdate();
  }
  get visibleElements() {
    return this._visibleElements;
  }
  getLazyObserver() {
    if (!this.useObserver)
      return null;
    if (this._lazyLoadObserver)
      return this._lazyLoadObserver;
    const t = new IntersectionObserver(
      (e) => {
        const s = e[0];
        if (!s.isIntersecting)
          return;
        const n = s.target;
        t.unobserve(n);
        const r = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length, o = [...this.elements][r];
        o && (this.visibleElements = [...this.visibleElements, o], t.observe(o));
      },
      { threshold: 0.5 }
    );
    return t;
  }
  observeLastElement() {
    const t = this.getLazyObserver();
    if (!t)
      return;
    const e = this.ELEMENTS_BEFORE_OBSERVER + this.visibleElements.length - 1, s = [...this.elements][e];
    s && t.observe(s);
  }
  resetVisibleElements() {
    const t = this.getLazyObserver();
    if (t) {
      for (const e of this.elements)
        t.unobserve(e);
      this.visibleElements = [], this.observeLastElement();
    }
  }
  /**
   * Creates a new UI component instance based on the provided template and initial state.
   *
   * @template T - The type of the UI component element.
   * @template S - The type of the component state.
   *
   * @param template - The component template function (stateless or stateful).
   * @param initialState - The initial state of the component (optional for stateless components).
   * @returns The created UI component element or an array containing the element and a function to update its state.
   */
  static create(t, e) {
    const s = document.createDocumentFragment();
    if (t.length === 0)
      return jt(t(), s), s.firstElementChild;
    if (!e)
      throw new Error(
        "UIComponent: Initial state is required for statefull components."
      );
    let n = e;
    const r = t, o = (c) => (n = { ...n, ...c }, jt(r(n), s), n);
    o(e);
    const a = () => n;
    return [s.firstElementChild, o, a];
  }
};
var el = Object.defineProperty;
var il = Object.getOwnPropertyDescriptor;
var zs = (i, t, e, s) => {
  for (var n = il(t, e), r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && el(t, e, n), n;
};
var P;
var Ai = (P = class extends w {
  constructor() {
    super(...arguments), this._previousContainer = null, this._visible = false;
  }
  get placement() {
    return this._placement;
  }
  set placement(t) {
    this._placement = t, this.updatePosition();
  }
  static removeMenus() {
    for (const t of P.menus)
      t instanceof P && (t.visible = false);
    P.dialog.close(), P.dialog.remove();
  }
  get visible() {
    return this._visible;
  }
  set visible(t) {
    var e;
    this._visible = t, t ? (P.dialog.parentElement || document.body.append(P.dialog), this._previousContainer = this.parentElement, P.dialog.style.top = `${window.scrollY || document.documentElement.scrollTop}px`, P.dialog.append(this), P.dialog.showModal(), this.updatePosition(), this.dispatchEvent(new Event("visible"))) : ((e = this._previousContainer) == null || e.append(this), this._previousContainer = null, this.dispatchEvent(new Event("hidden")));
  }
  /**
   * Asynchronously updates the position of the context menu relative to a target element.
   * If no target element is provided, it attempts to use the parent node as the target.
   * The position is calculated using the `computePosition` function from `@floating-ui/dom`,
   * which considers various adjustments like offset, inline positioning, flipping, and shifting
   * to ensure the context menu is properly placed relative to the target element.
   *
   * @param [target] - The target element relative to which the context menu should be positioned.
   *                                 If not provided, the parent node is used as the target.
   * @returns A promise that resolves once the position has been updated. This method
   *                          does not explicitly return a value but updates the context menu's style
   *                          properties to position it on the screen.
   */
  async updatePosition() {
    if (!(this.visible && this._previousContainer))
      return;
    const t = this.placement ?? "right", e = await is(this._previousContainer, this, {
      placement: t,
      middleware: [Vn(10), es(), ts(), Zn({ padding: 5 })]
    }), { x: s, y: n } = e;
    this.style.left = `${s}px`, this.style.top = `${n}px`;
  }
  connectedCallback() {
    super.connectedCallback(), P.menus.push(this);
  }
  render() {
    return m` <slot></slot> `;
  }
}, P.styles = [
  vt.scrollbar,
  C`
      :host {
        pointer-events: auto;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 999;
        overflow: auto;
        max-height: 20rem;
        min-width: 3rem;
        flex-direction: column;
        box-shadow: 1px 2px 8px 2px rgba(0, 0, 0, 0.15);
        padding: 0.5rem;
        border-radius: var(--bim-ui_size-4xs);
        display: flex;
        background-color: var(
          --bim-context-menu--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      :host(:not([visible])) {
        display: none;
      }
    `
], P.dialog = Rs.create(() => m` <dialog
      @click=${(e) => {
  e.target === P.dialog && P.removeMenus();
}}
      @cancel=${() => P.removeMenus()}
      data-context-dialog
      style="
      width: 0;
      height: 0;
      position: relative;
      padding: 0;
      border: none;
      outline: none;
      margin: none;
      overflow: visible;
      background-color: transparent;
    "
    ></dialog>`), P.menus = [], P);
zs([
  h({ type: String, reflect: true })
], Ai.prototype, "placement");
zs([
  h({ type: Boolean, reflect: true })
], Ai.prototype, "visible");
var nl = Ai;
var Pe = (i, t = {}, e = true) => {
  let s = {};
  for (const n of i.children) {
    const r = n, o = r.getAttribute("name") || r.getAttribute("label"), a = t[o];
    if (o) {
      if ("value" in r && typeof r.value < "u" && r.value !== null) {
        const l = r.value;
        if (typeof l == "object" && !Array.isArray(l) && Object.keys(l).length === 0)
          continue;
        s[o] = a ? a(r.value) : r.value;
      } else if (e) {
        const l = Pe(r, t);
        if (Object.keys(l).length === 0)
          continue;
        s[o] = a ? a(l) : l;
      }
    } else
      e && (s = { ...s, ...Pe(r, t) });
  }
  return s;
};
var Fe = (i) => i === "true" || i === "false" ? i === "true" : i && !isNaN(Number(i)) && i.trim() !== "" ? Number(i) : i;
var sl = [">=", "<=", "=", ">", "<", "?", "/", "#"];
function In(i) {
  const t = sl.find(
    (a) => i.split(a).length === 2
  ), e = i.split(t).map((a) => a.trim()), [s, n] = e, r = n.startsWith("'") && n.endsWith("'") ? n.replace(/'/g, "") : Fe(n);
  return { key: s, condition: t, value: r };
}
var fi = (i) => {
  try {
    const t = [], e = i.split(/&(?![^()]*\))/).map((s) => s.trim());
    for (const s of e) {
      const n = !s.startsWith("(") && !s.endsWith(")"), r = s.startsWith("(") && s.endsWith(")");
      if (n) {
        const o = In(s);
        t.push(o);
      }
      if (r) {
        const c = {
          operator: "&",
          queries: s.replace(/^(\()|(\))$/g, "").split("&").map((u) => u.trim()).map((u, d) => {
            const f = In(u);
            return d > 0 && (f.operator = "&"), f;
          })
        };
        t.push(c);
      }
    }
    return t;
  } catch {
    return null;
  }
};
var Rn = (i, t, e) => {
  let s = false;
  switch (t) {
    case "=":
      s = i === e;
      break;
    case "?":
      s = String(i).includes(String(e));
      break;
    case "<":
      (typeof i == "number" || typeof e == "number") && (s = i < e);
      break;
    case "<=":
      (typeof i == "number" || typeof e == "number") && (s = i <= e);
      break;
    case ">":
      (typeof i == "number" || typeof e == "number") && (s = i > e);
      break;
    case ">=":
      (typeof i == "number" || typeof e == "number") && (s = i >= e);
      break;
    case "/":
      s = String(i).startsWith(String(e));
      break;
  }
  return s;
};
var rl = Object.defineProperty;
var ol = Object.getOwnPropertyDescriptor;
var yt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? ol(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && rl(t, e, n), n;
};
var Li = class Li2 extends w {
  constructor() {
    super(...arguments), this.checked = false, this.checkbox = false, this.noMark = false, this.vertical = false;
  }
  get value() {
    return this._value !== void 0 ? this._value : this.label ? Fe(this.label) : this.label;
  }
  set value(t) {
    this._value = t;
  }
  render() {
    return m`
      <div class="parent" .title=${this.label ?? ""}>
        ${this.img || this.icon || this.label ? m` <div style="display: flex; column-gap: 0.375rem">
              ${this.checkbox && !this.noMark ? m`<bim-checkbox
                    style="pointer-events: none"
                    .checked=${this.checked}
                  ></bim-checkbox>` : null}
              <bim-label
                .vertical=${this.vertical}
                .icon=${this.icon}
                .img=${this.img}
                >${this.label}</bim-label
              >
            </div>` : null}
        ${!this.checkbox && !this.noMark && this.checked ? m`<svg
              xmlns="http://www.w3.org/2000/svg"
              height="1.125rem"
              viewBox="0 0 24 24"
              width="1.125rem"
              fill="#FFFFFF"
            >
              <path d="M0 0h24v24H0z" fill="none" />
              <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z" />
            </svg>` : null}
        <slot></slot>
      </div>
    `;
  }
};
Li.styles = C`
    :host {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
      display: block;
      box-sizing: border-box;
      flex: 1;
      padding: 0rem 0.5rem;
      border-radius: var(--bim-ui_size-4xs);
      transition: all 0.15s;
    }

    :host(:hover) {
      cursor: pointer;
      background-color: color-mix(
        in lab,
        var(--bim-selector--bgc, var(--bim-ui_bg-contrast-20)),
        var(--bim-ui_main-base) 10%
      );
    }

    :host([checked]) {
      --bim-label--c: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    :host([checked]) svg {
      fill: color-mix(in lab, var(--bim-ui_main-base), white 30%);
    }

    .parent {
      box-sizing: border-box;
      display: flex;
      justify-content: var(--bim-option--jc, space-between);
      column-gap: 0.5rem;
      align-items: center;
      min-height: 1.75rem;
      height: 100%;
    }

    input {
      height: 1rem;
      width: 1rem;
      cursor: pointer;
      border: none;
      outline: none;
      accent-color: var(--bim-checkbox--c, var(--bim-ui_main-base));
    }

    input:focus {
      outline: var(--bim-checkbox--olw, 2px) solid
        var(--bim-checkbox--olc, var(--bim-ui_accent-base));
    }

    bim-label {
      pointer-events: none;
    }
  `;
var T = Li;
yt([
  h({ type: String, reflect: true })
], T.prototype, "img", 2);
yt([
  h({ type: String, reflect: true })
], T.prototype, "label", 2);
yt([
  h({ type: String, reflect: true })
], T.prototype, "icon", 2);
yt([
  h({ type: Boolean, reflect: true })
], T.prototype, "checked", 2);
yt([
  h({ type: Boolean, reflect: true })
], T.prototype, "checkbox", 2);
yt([
  h({ type: Boolean, attribute: "no-mark", reflect: true })
], T.prototype, "noMark", 2);
yt([
  h({
    converter: {
      fromAttribute(i) {
        return i && Fe(i);
      }
    }
  })
], T.prototype, "value", 1);
yt([
  h({ type: Boolean, reflect: true })
], T.prototype, "vertical", 2);
var ll = Object.defineProperty;
var al = Object.getOwnPropertyDescriptor;
var _t = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? al(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && ll(t, e, n), n;
};
var Ii = class Ii2 extends Rs {
  constructor() {
    super(), this.multiple = false, this.required = false, this.vertical = false, this._visible = false, this._value = /* @__PURE__ */ new Set(), this.onValueChange = new Event("change"), this._contextMenu = Bt(), this.onOptionClick = (t) => {
      const e = t.target, s = this._value.has(e);
      if (!this.multiple && !this.required && !s)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (!this.multiple && !this.required && s)
        this._value = /* @__PURE__ */ new Set([]);
      else if (!this.multiple && this.required && !s)
        this._value = /* @__PURE__ */ new Set([e]);
      else if (this.multiple && !this.required && !s)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && !this.required && s) {
        const n = [...this._value].filter((r) => r !== e);
        this._value = new Set(n);
      } else if (this.multiple && this.required && !s)
        this._value = /* @__PURE__ */ new Set([...this._value, e]);
      else if (this.multiple && this.required && s) {
        const n = [...this._value].filter((o) => o !== e), r = new Set(n);
        r.size !== 0 && (this._value = r);
      }
      this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
    }, this.useObserver = true;
  }
  set visible(t) {
    if (t) {
      const { value: e } = this._contextMenu;
      if (!e)
        return;
      for (const s of this.elements)
        e.append(s);
      this._visible = true;
    } else {
      for (const e of this.elements)
        this.append(e);
      this._visible = false, this.resetVisibleElements();
    }
  }
  get visible() {
    return this._visible;
  }
  /**
   * The selected values in the dropdown.
   * @type {any[]}
   * @example
   * const dropdown = document.createElement('bim-dropdown');
   * dropdown.value = ['option1', 'option2'];
   */
  set value(t) {
    if (this.required && Object.keys(t).length === 0)
      return;
    const e = /* @__PURE__ */ new Set();
    for (const s of t) {
      const n = this.findOption(s);
      if (n && (e.add(n), !this.multiple && Object.keys(t).length === 1))
        break;
    }
    this._value = e, this.updateOptionsState(), this.dispatchEvent(this.onValueChange);
  }
  get value() {
    return [...this._value].filter(
      (e) => e instanceof T && e.checked
    ).map((e) => e.value);
  }
  get _options() {
    const t = /* @__PURE__ */ new Set([...this.elements]);
    for (const e of this.children)
      e instanceof T && t.add(e);
    return [...t];
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    this.observe(e);
    const s = /* @__PURE__ */ new Set();
    for (const n of this.elements) {
      if (!(n instanceof T)) {
        n.remove();
        continue;
      }
      n.checked && s.add(n), n.removeEventListener("click", this.onOptionClick), n.addEventListener("click", this.onOptionClick);
    }
    this._value = s;
  }
  updateOptionsState() {
    for (const t of this._options)
      t instanceof T && (t.checked = this._value.has(t));
  }
  findOption(t) {
    return this._options.find((s) => s instanceof T ? s.label === t || s.value === t : false);
  }
  render() {
    let t, e, s;
    if (this._value.size === 0)
      t = "Select an option...";
    else if (this._value.size === 1) {
      const n = [...this._value][0];
      t = (n == null ? void 0 : n.label) || (n == null ? void 0 : n.value), e = n == null ? void 0 : n.img, s = n == null ? void 0 : n.icon;
    } else
      t = `Multiple (${this._value.size})`;
    return m`
      <bim-input
        title=${this.label ?? ""}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        <div class="input" @click=${() => this.visible = !this.visible}>
          <bim-label
            .img=${e}
            .icon=${s}
            style="overflow: hidden;"
            >${t}</bim-label
          >
          <svg
            style="flex-shrink: 0; fill: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100))"
            xmlns="http://www.w3.org/2000/svg"
            height="1.125rem"
            viewBox="0 0 24 24"
            width="1.125rem"
            fill="#9ca3af"
          >
            <path d="M0 0h24v24H0V0z" fill="none" />
            <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
          </svg>
          <bim-context-menu
            ${Ht(this._contextMenu)}
            .visible=${this.visible}
            @hidden=${() => {
      this.visible && (this.visible = false);
    }}
          >
            <slot @slotchange=${this.onSlotChange}></slot>
          </bim-context-menu>
        </div>
      </bim-input>
    `;
  }
};
Ii.styles = [
  vt.scrollbar,
  C`
      :host {
        --bim-input--bgc: var(
          --bim-dropdown--bgc,
          var(--bim-ui_bg-contrast-20)
        );
        --bim-input--olw: 2px;
        --bim-input--olc: transparent;
        --bim-input--bdrs: var(--bim-ui_size-4xs);
        flex: 1;
        display: block;
      }

      :host([visible]) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      .input {
        --bim-label--fz: var(--bim-drodown--fz, var(--bim-ui_size-xs));
        --bim-label--c: var(--bim-dropdown--c, var(--bim-ui_bg-contrast-100));
        height: 100%;
        display: flex;
        flex: 1;
        overflow: hidden;
        column-gap: 0.25rem;
        outline: none;
        cursor: pointer;
        align-items: center;
        justify-content: space-between;
        padding: 0 0.5rem;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
var V = Ii;
_t([
  h({ type: String, reflect: true })
], V.prototype, "name", 2);
_t([
  h({ type: String, reflect: true })
], V.prototype, "icon", 2);
_t([
  h({ type: String, reflect: true })
], V.prototype, "label", 2);
_t([
  h({ type: Boolean, reflect: true })
], V.prototype, "multiple", 2);
_t([
  h({ type: Boolean, reflect: true })
], V.prototype, "required", 2);
_t([
  h({ type: Boolean, reflect: true })
], V.prototype, "vertical", 2);
_t([
  h({ type: Boolean, reflect: true })
], V.prototype, "visible", 1);
_t([
  Ft()
], V.prototype, "_value", 2);
var cl = Object.defineProperty;
var Ms = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && cl(t, e, n), n;
};
var Ri = class Ri2 extends w {
  constructor() {
    super(...arguments), this.floating = false, this.layouts = {};
  }
  // private isVerticalArea(area: string) {
  //   const { rows } = this;
  //   const row = rows.find((row) => row.includes(area));
  //   if (!row)
  //     throw new Error(
  //       `${area} wasn't defined in the grid-template of this bim-grid`,
  //     );
  //   const index = rows.indexOf(row);
  //   const abovePanel = index > 0 && rows[index - 1].includes(area);
  //   const belowPanel =
  //     index < rows.length - 1 && rows[index + 1].includes(area);
  //   return abovePanel || belowPanel;
  // }
  getUniqueAreasFromTemplate(t) {
    const n = t.split(`
`).map((o) => o.trim()).map((o) => o.split('"')[1]).filter((o) => o !== void 0).flatMap((o) => o.split(/\s+/));
    return [...new Set(n)].filter((o) => o !== "");
  }
  firstUpdated() {
    this._onLayoutChange = new Event("layoutchange");
  }
  render() {
    if (this.layout) {
      if (this.layouts[this.layout]) {
        this.innerHTML = "";
        const t = this.layouts[this.layout], s = this.getUniqueAreasFromTemplate(t.template).map((n) => {
          const r = t.elements[n];
          return r && (r.style.gridArea = n), r;
        }).filter((n) => !!n);
        this.style.gridTemplate = t.template, this._onLayoutChange && this.dispatchEvent(this._onLayoutChange), this.append(...s);
      }
    } else
      this.innerHTML = "", this.style.gridTemplate = "", this._onLayoutChange && this.dispatchEvent(this._onLayoutChange);
    return m`<slot></slot>`;
  }
};
Ri.styles = C`
    :host {
      display: grid;
      height: 100%;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
    }

    /* :host(:not([layout])) {
      display: none;
    } */

    :host([floating]) {
      --bim-panel--bdrs: var(--bim-ui_size-4xs);
      background-color: transparent;
      padding: 1rem;
      gap: 1rem;
      position: absolute;
      pointer-events: none;
      top: 0px;
      left: 0px;
    }

    :host(:not([floating])) {
      --bim-panel--bdrs: 0;
      background-color: var(--bim-ui_bg-contrast-20);
      gap: 1px;
    }
  `;
var le = Ri;
Ms([
  h({ type: Boolean, reflect: true })
], le.prototype, "floating");
Ms([
  h({ type: String, reflect: true })
], le.prototype, "layout");
var ze = class ze2 extends w {
  render() {
    return m`
      <iconify-icon .icon=${this.icon} height="none"></iconify-icon>
    `;
  }
};
ze.styles = C`
    :host {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
    }

    iconify-icon {
      height: var(--bim-icon--fz, var(--bim-ui_size-sm));
      width: var(--bim-icon--fz, var(--bim-ui_size-sm));
      color: var(--bim-icon--c);
      transition: all 0.15s;
    }
  `, ze.properties = {
  icon: { type: String }
};
var pi = ze;
var ul = Object.defineProperty;
var Ve = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && ul(t, e, n), n;
};
var zi = class zi2 extends w {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change");
  }
  get value() {
    const t = {};
    for (const e of this.children) {
      const s = e;
      "value" in s ? t[s.name || s.label] = s.value : "checked" in s && (t[s.name || s.label] = s.checked);
    }
    return t;
  }
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((a) => {
        const l = a;
        return l.name === s || l.label === s;
      });
      if (!n)
        continue;
      const r = n, o = t[s];
      typeof o == "boolean" ? r.checked = o : r.value = o;
    }
  }
  render() {
    return m`
      <div class="parent">
        ${this.label || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="input">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
zi.styles = C`
    :host {
      flex: 1;
      display: block;
    }

    .parent {
      display: flex;
      flex-wrap: wrap;
      column-gap: 1rem;
      row-gap: 0.375rem;
      user-select: none;
      flex: 1;
    }

    :host(:not([vertical])) .parent {
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .input {
      overflow: hidden;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      min-height: 1.75rem;
      min-width: 3rem;
      gap: var(--bim-input--g, var(--bim-ui_size-4xs));
      padding: var(--bim-input--p, 0);
      background-color: var(--bim-input--bgc, transparent);
      outline: var(--bim-input--olw, 2px) solid
        var(--bim-input--olc, transparent);
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
      transition: all 0.15s;
    }

    :host(:not([vertical])) .input {
      flex: 1;
      justify-content: flex-end;
    }

    :host(:not([vertical])[label]) .input {
      max-width: fit-content;
    }
  `;
var At = zi;
Ve([
  h({ type: String, reflect: true })
], At.prototype, "name");
Ve([
  h({ type: String, reflect: true })
], At.prototype, "label");
Ve([
  h({ type: String, reflect: true })
], At.prototype, "icon");
Ve([
  h({ type: Boolean, reflect: true })
], At.prototype, "vertical");
var hl = Object.defineProperty;
var pe = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && hl(t, e, n), n;
};
var Mi = class Mi2 extends w {
  constructor() {
    super(...arguments), this.labelHidden = false, this.iconHidden = false, this.vertical = false;
  }
  get value() {
    return this.textContent ? Fe(this.textContent) : this.textContent;
  }
  render() {
    return m`
      <div class="parent" .title=${this.textContent ?? ""}>
        ${this.img ? m`<img .src=${this.img} .alt=${this.textContent || ""} />` : null}
        ${!this.iconHidden && this.icon ? m`<bim-icon .icon=${this.icon}></bim-icon>` : null}
        <p><slot></slot></p>
      </div>
    `;
  }
};
Mi.styles = C`
    :host {
      --bim-icon--c: var(--bim-label--c);
      color: var(--bim-label--c, var(--bim-ui_bg-contrast-60));
      font-size: var(--bim-label--fz, var(--bim-ui_size-xs));
      overflow: hidden;
      display: block;
      white-space: nowrap;
      line-height: 1.1rem;
      transition: all 0.15s;
    }

    .parent {
      display: flex;
      align-items: center;
      column-gap: 0.25rem;
      row-gap: 0.125rem;
      user-select: none;
      height: 100%;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    .parent p {
      margin: 0;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    :host([label-hidden]) .parent p,
    :host(:empty) .parent p {
      display: none;
    }

    img {
      height: 100%;
      aspect-ratio: 1;
      border-radius: 100%;
      margin-right: 0.125rem;
    }

    :host(:not([vertical])) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 1.8)
      );
    }

    :host([vertical]) img {
      max-height: var(
        --bim-label_icon--sz,
        calc(var(--bim-label--fz, var(--bim-ui_size-xs)) * 4)
      );
    }
  `;
var ft = Mi;
pe([
  h({ type: String, reflect: true })
], ft.prototype, "img");
pe([
  h({ type: Boolean, attribute: "label-hidden", reflect: true })
], ft.prototype, "labelHidden");
pe([
  h({ type: String, reflect: true })
], ft.prototype, "icon");
pe([
  h({ type: Boolean, attribute: "icon-hidden", reflect: true })
], ft.prototype, "iconHidden");
pe([
  h({ type: Boolean, reflect: true })
], ft.prototype, "vertical");
var dl = Object.defineProperty;
var fl = Object.getOwnPropertyDescriptor;
var N = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? fl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && dl(t, e, n), n;
};
var ji = class ji2 extends w {
  constructor() {
    super(...arguments), this._value = 0, this.vertical = false, this.slider = false, this._input = Bt(), this.onValueChange = new Event("change");
  }
  set value(t) {
    this.setValue(t.toString());
  }
  get value() {
    return this._value;
  }
  onChange(t) {
    t.stopPropagation();
    const { value: e } = this._input;
    e && this.setValue(e.value);
  }
  setValue(t) {
    const { value: e } = this._input;
    let s = t;
    if (s = s.replace(/[^0-9.-]/g, ""), s = s.replace(/(\..*)\./g, "$1"), s.endsWith(".") || (s.lastIndexOf("-") > 0 && (s = s[0] + s.substring(1).replace(/-/g, "")), s === "-" || s === "-0"))
      return;
    let n = Number(s);
    Number.isNaN(n) || (n = this.min !== void 0 ? Math.max(n, this.min) : n, n = this.max !== void 0 ? Math.min(n, this.max) : n, this.value !== n && (this._value = n, e && (e.value = this.value.toString()), this.requestUpdate(), this.dispatchEvent(this.onValueChange)));
  }
  onBlur() {
    const { value: t } = this._input;
    t && Number.isNaN(Number(t.value)) && (t.value = this.value.toString());
  }
  onSliderMouseDown(t) {
    document.body.style.cursor = "w-resize";
    const { clientX: e } = t, s = this.value;
    let n = false;
    const r = (l) => {
      var v;
      n = true;
      const { clientX: c } = l, u = this.step ?? 1, d = ((v = u.toString().split(".")[1]) == null ? void 0 : v.length) || 0, f = 1 / (this.sensitivity ?? 1), p = (c - e) / f;
      if (Math.floor(Math.abs(p)) !== Math.abs(p))
        return;
      const b = s + p * u;
      this.setValue(b.toFixed(d));
    }, o = () => {
      this.slider = true, this.removeEventListener("blur", o);
    }, a = () => {
      document.removeEventListener("mousemove", r), document.body.style.cursor = "default", n ? n = false : (this.addEventListener("blur", o), this.slider = false, requestAnimationFrame(() => this.focus())), document.removeEventListener("mouseup", a);
    };
    document.addEventListener("mousemove", r), document.addEventListener("mouseup", a);
  }
  onFocus(t) {
    t.stopPropagation();
    const e = (s) => {
      s.key === "Escape" && (this.blur(), window.removeEventListener("keydown", e));
    };
    window.addEventListener("keydown", e);
  }
  connectedCallback() {
    super.connectedCallback(), this.min && this.min > this.value && (this._value = this.min), this.max && this.max < this.value && (this._value = this.max);
  }
  /**
   * Sets focus to the input element of the number input component.
   * This method is useful for programmatically focusing the input element, for example,
   * in response to a user action or to emphasize the input in the UI.
   *
   * If the input element reference is not available (not yet rendered or disconnected),
   * this method will do nothing.
   */
  focus() {
    const { value: t } = this._input;
    t && t.focus();
  }
  render() {
    const t = m`
      ${this.pref || this.icon ? m`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            .icon=${this.icon}
            >${this.pref}</bim-label
          >` : null}
      <input
        ${Ht(this._input)}
        type="text"
        aria-label=${this.label || this.name || "Number Input"}
        size="1"
        @input=${(a) => a.stopPropagation()}
        @change=${this.onChange}
        @blur=${this.onBlur}
        @focus=${this.onFocus}
        .value=${this.value.toString()}
      />
      ${this.suffix ? m`<bim-label
            style="pointer-events: auto"
            @mousedown=${this.onSliderMouseDown}
            >${this.suffix}</bim-label
          >` : null}
    `, e = this.min ?? -1 / 0, s = this.max ?? 1 / 0, n = 100 * (this.value - e) / (s - e), r = m`
      <style>
        .slider-indicator {
          width: ${`${n}%`};
        }
      </style>
      <div class="slider" @mousedown=${this.onSliderMouseDown}>
        <div class="slider-indicator"></div>
        ${this.pref || this.icon ? m`<bim-label
              style="z-index: 1; margin-right: 0.125rem"
              .icon=${this.icon}
              >${`${this.pref}: `}</bim-label
            >` : null}
        <bim-label style="z-index: 1;">${this.value}</bim-label>
        ${this.suffix ? m`<bim-label style="z-index: 1;">${this.suffix}</bim-label>` : null}
      </div>
    `, o = `${this.label || this.name || this.pref ? `${this.label || this.name || this.pref}: ` : ""}${this.value}${this.suffix ?? ""}`;
    return m`
      <bim-input
        title=${o}
        .label=${this.label}
        .icon=${this.icon}
        .vertical=${this.vertical}
      >
        ${this.slider ? r : t}
      </bim-input>
    `;
  }
};
ji.styles = C`
    :host {
      --bim-input--bgc: var(
        --bim-number-input--bgc,
        var(--bim-ui_bg-contrast-20)
      );
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(--bim-number-input--olc, transparent);
      --bim-input--bdrs: var(--bim-number-input--bdrs, var(--bim-ui_size-4xs));
      --bim-input--p: 0 0.375rem;
      flex: 1;
      display: block;
    }

    :host(:focus) {
      --bim-input--olw: var(--bim-number-input--olw, 2px);
      --bim-input--olc: var(
        --bim-number-input¡focus--c,
        var(--bim-ui_accent-base)
      );
    }

    :host(:not([slider])) bim-label {
      --bim-label--c: var(
        --bim-number-input_affixes--c,
        var(--bim-ui_bg-contrast-60)
      );
      --bim-label--fz: var(
        --bim-number-input_affixes--fz,
        var(--bim-ui_size-xs)
      );
    }

    p {
      margin: 0;
      padding: 0;
    }

    input {
      background-color: transparent;
      outline: none;
      border: none;
      padding: 0;
      flex-grow: 1;
      text-align: right;
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: var(--bim-number-input--fz, var(--bim-ui_size-xs));
      color: var(--bim-number-input--c, var(--bim-ui_bg-contrast-100));
    }

    :host([suffix]:not([pref])) input {
      text-align: left;
    }

    :host([slider]) {
      --bim-input--p: 0;
    }

    :host([slider]) .slider {
      --bim-label--c: var(--bim-ui_bg-contrast-100);
    }

    .slider {
      position: relative;
      display: flex;
      justify-content: center;
      width: 100%;
      height: 100%;
      padding: 0 0.5rem;
    }

    .slider-indicator {
      height: 100%;
      background-color: var(--bim-ui_main-base);
      position: absolute;
      top: 0;
      left: 0;
      border-radius: var(--bim-input--bdrs, var(--bim-ui_size-4xs));
    }

    bim-input {
      display: flex;
    }

    bim-label {
      pointer-events: none;
    }
  `;
var I = ji;
N([
  h({ type: String, reflect: true })
], I.prototype, "name", 2);
N([
  h({ type: String, reflect: true })
], I.prototype, "icon", 2);
N([
  h({ type: String, reflect: true })
], I.prototype, "label", 2);
N([
  h({ type: String, reflect: true })
], I.prototype, "pref", 2);
N([
  h({ type: Number, reflect: true })
], I.prototype, "min", 2);
N([
  h({ type: Number, reflect: true })
], I.prototype, "value", 1);
N([
  h({ type: Number, reflect: true })
], I.prototype, "step", 2);
N([
  h({ type: Number, reflect: true })
], I.prototype, "sensitivity", 2);
N([
  h({ type: Number, reflect: true })
], I.prototype, "max", 2);
N([
  h({ type: String, reflect: true })
], I.prototype, "suffix", 2);
N([
  h({ type: Boolean, reflect: true })
], I.prototype, "vertical", 2);
N([
  h({ type: Boolean, reflect: true })
], I.prototype, "slider", 2);
var pl = Object.defineProperty;
var ml = Object.getOwnPropertyDescriptor;
var me = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? ml(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && pl(t, e, n), n;
};
var Bi = class Bi2 extends w {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this._hidden = false, this.headerHidden = false, this.valueTransform = {}, this.activationButton = document.createElement("bim-button");
  }
  set hidden(t) {
    this._hidden = t, this.activationButton.active = !t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  /**
   * The `value` getter computes and returns the current state of the panel's form elements as an object. This property is dynamic and reflects the current input values within the panel. When accessed, it traverses the panel's child elements, collecting values from those that have a `name` or `label` attribute, and constructs an object where each key corresponds to the `name` or `label` of the element, and the value is the element's value. This property is particularly useful for forms or interactive panels where the user's input needs to be retrieved programmatically. The value returned is a snapshot of the panel's state at the time of access, and it does not maintain a live link to the input elements.
   *
   * @default {}
   * @example <bim-panel></bim-panel> <!-- Access via JavaScript to get value -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * console.log(panel.value); // Logs the current value object of the panel
   */
  get value() {
    return Pe(this, this.valueTransform);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel's form elements. When a data object is passed to this property, it attempts to match the object's keys with the `name` or `label` attributes of the panel's child elements. If a match is found, the corresponding element's value is updated to the value associated with the key in the data object. This property is useful for initializing the panel with specific data or updating its state based on external inputs. Note that this operation does not affect elements without a matching `name` or `label`, and it only updates the values of elements that are direct children of the panel.
   *
   * @type {Record<string, any>}
   * @example <bim-panel></bim-panel> <!-- Set value via JavaScript -->
   * @example
   * const panel = document.createElement('bim-panel');
   * document.body.appendChild(panel);
   * panel.value = { 'input-name': 'John Doe', 'checkbox-name': true };
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  connectedCallback() {
    super.connectedCallback(), this.activationButton.active = !this.hidden, this.activationButton.onclick = () => this.hidden = !this.hidden;
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.activationButton.remove();
  }
  /**
   * Collapses all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `true`,
   * effectively hiding their content from view. This can be used to programmatically minimize the space taken up by sections
   * within the panel, making the panel more compact or to hide details that are not immediately necessary.
   */
  collapseSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = true;
  }
  /**
   * Expands all `bim-panel-section` elements within the panel.
   * This method iterates over each `bim-panel-section` found within the panel's DOM and sets their `collapsed` property to `false`,
   * effectively showing their content. This can be used to programmatically reveal the content of sections within the panel,
   * making the panel more informative or to display details that are necessary for the user.
   */
  expandSections() {
    const t = this.querySelectorAll("bim-panel-section");
    for (const e of t)
      e.collapsed = false;
  }
  render() {
    return this.activationButton.icon = this.icon, this.activationButton.label = this.label || this.name, this.activationButton.tooltipTitle = this.label || this.name, m`
      <div class="parent">
        ${this.label || this.name || this.icon ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        <div class="sections">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Bi.styles = [
  vt.scrollbar,
  C`
      :host {
        display: flex;
        border-radius: var(--bim-ui_size-base);
        background-color: var(--bim-ui_bg-base);
        overflow: auto;
      }

      :host([hidden]) {
        display: none;
      }

      .parent {
        display: flex;
        flex: 1;
        flex-direction: column;
        pointer-events: auto;
        overflow: auto;
      }

      .parent bim-label {
        --bim-label--c: var(--bim-panel--c, var(--bim-ui_bg-contrast-80));
        --bim-label--fz: var(--bim-panel--fz, var(--bim-ui_size-sm));
        font-weight: 600;
        padding: 1rem;
        flex-shrink: 0;
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([header-hidden]) .parent bim-label {
        display: none;
      }

      .sections {
        display: flex;
        flex-direction: column;
        overflow: auto;
      }

      ::slotted(bim-panel-section:not(:last-child)) {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }
    `
];
var Z = Bi;
me([
  h({ type: String, reflect: true })
], Z.prototype, "icon", 2);
me([
  h({ type: String, reflect: true })
], Z.prototype, "name", 2);
me([
  h({ type: String, reflect: true })
], Z.prototype, "label", 2);
me([
  h({ type: Boolean, reflect: true })
], Z.prototype, "hidden", 1);
me([
  h({ type: Boolean, attribute: "header-hidden", reflect: true })
], Z.prototype, "headerHidden", 2);
var bl = Object.defineProperty;
var be = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && bl(t, e, n), n;
};
var Hi = class Hi2 extends w {
  constructor() {
    super(...arguments), this.onValueChange = new Event("change"), this.valueTransform = {};
  }
  /**
   * The `value` getter computes and returns the current state of the panel section's form elements as an object. This object's keys are the `name` or `label` attributes of the child elements, and the values are the corresponding values of these elements. This property is particularly useful for retrieving a consolidated view of the user's input or selections within the panel section. When the value of any child element changes, the returned object from this getter will reflect those changes, providing a dynamic snapshot of the panel section's state. Note that this property does not have a default value as it dynamically reflects the current state of the panel section's form elements.
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a getter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * console.log(section.value); // Logs the current value object
   */
  get value() {
    const t = this.parentElement;
    let e;
    return t instanceof Z && (e = t.valueTransform), Object.values(this.valueTransform).length !== 0 && (e = this.valueTransform), Pe(this, e);
  }
  /**
   * The `value` setter allows programmatically updating the values of the panel section's child elements. It accepts an object where keys correspond to the `name` or `label` attributes of the child elements, and the values are the new values to be set for these elements. This property is useful for initializing the panel section with specific values or updating its state based on external data. When the property changes, the corresponding child elements' values are updated to reflect the new state. This does not have a default value as it is a method for updating child elements' values.
   * @type {Record<string, any>}
   * @default undefined
   * @example <bim-panel-section></bim-panel-section> <!-- Usage in HTML not directly applicable as this is a setter -->
   * @example
   * const section = document.createElement('bim-panel-section');
   * section.value = { 'user-settings': 'John Doe' }; // Programmatically sets the value of a child element named 'user-settings'
   */
  set value(t) {
    const e = [...this.children];
    for (const s in t) {
      const n = e.find((o) => {
        const a = o;
        return a.name === s || a.label === s;
      });
      if (!n)
        continue;
      const r = n;
      r.value = t[s];
    }
  }
  onHeaderClick() {
    this.fixed || (this.collapsed = !this.collapsed);
  }
  render() {
    const t = this.label || this.icon || this.name || this.fixed, e = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0V0z" fill="none" />
      <path d="M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" />
    </svg>`, s = m`<svg
      xmlns="http://www.w3.org/2000/svg"
      height="1.125rem"
      viewBox="0 0 24 24"
      width="1.125rem"
    >
      <path d="M0 0h24v24H0z" fill="none" />
      <path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z" />
    </svg>`, n = this.collapsed ? e : s, r = m`
      <div
        class="header"
        title=${this.label ?? ""}
        @click=${this.onHeaderClick}
      >
        ${this.label || this.icon || this.name ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
        ${this.fixed ? null : n}
      </div>
    `;
    return m`
      <div class="parent">
        ${t ? r : null}
        <div class="components">
          <slot></slot>
        </div>
      </div>
    `;
  }
};
Hi.styles = [
  vt.scrollbar,
  C`
      :host {
        display: block;
        pointer-events: auto;
      }

      :host(:not([fixed])) .header:hover {
        --bim-label--c: var(--bim-ui_accent-base);
        color: var(--bim-ui_accent-base);
        cursor: pointer;
      }

      :host(:not([fixed])) .header:hover svg {
        fill: var(--bim-ui_accent-base);
      }

      .header {
        --bim-label--fz: var(--bim-ui_size-sm);
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: 600;
        height: 1.5rem;
        padding: 0.75rem 1rem;
      }

      .header svg {
        fill: var(--bim-ui_bg-contrast-80);
      }

      .title {
        display: flex;
        align-items: center;
        column-gap: 0.5rem;
      }

      .title p {
        font-size: var(--bim-ui_size-sm);
      }

      .components {
        display: flex;
        flex-direction: column;
        row-gap: 0.75rem;
        padding: 0.125rem 1rem 1rem;
      }

      :host(:not([fixed])[collapsed]) .components {
        display: none;
        height: 0px;
      }

      bim-label {
        pointer-events: none;
      }
    `
];
var pt = Hi;
be([
  h({ type: String, reflect: true })
], pt.prototype, "icon");
be([
  h({ type: String, reflect: true })
], pt.prototype, "label");
be([
  h({ type: String, reflect: true })
], pt.prototype, "name");
be([
  h({ type: Boolean, reflect: true })
], pt.prototype, "fixed");
be([
  h({ type: Boolean, reflect: true })
], pt.prototype, "collapsed");
var gl = Object.defineProperty;
var ge = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && gl(t, e, n), n;
};
var Ni = class Ni2 extends w {
  constructor() {
    super(...arguments), this.vertical = false, this.onValueChange = new Event("change"), this._canEmitEvents = false, this._value = document.createElement("bim-option"), this.onOptionClick = (t) => {
      this._value = t.target, this.dispatchEvent(this.onValueChange);
      for (const e of this.children)
        e instanceof T && (e.checked = e === t.target);
    };
  }
  get _options() {
    return [...this.querySelectorAll("bim-option")];
  }
  /**
   * Sets the value of the selector.
   * It finds the matching option based on the provided value and sets it as the selected option.
   * If no matching option is found, it does nothing.
   *
   * @param value - The value to set for the selector.
   */
  set value(t) {
    const e = this.findOption(t);
    if (e) {
      for (const s of this._options)
        s.checked = s === e;
      this._value = e, this._canEmitEvents && this.dispatchEvent(this.onValueChange);
    }
  }
  get value() {
    return this._value.value;
  }
  onSlotChange(t) {
    const e = t.target.assignedElements();
    for (const s of e)
      s instanceof T && (s.noMark = true, s.removeEventListener("click", this.onOptionClick), s.addEventListener("click", this.onOptionClick));
  }
  findOption(t) {
    return this._options.find((s) => s instanceof T ? s.label === t || s.value === t : false);
  }
  firstUpdated() {
    const t = [...this.children].find(
      (e) => e instanceof T && e.checked
    );
    t && (this._value = t);
  }
  render() {
    return m`
      <bim-input
        .vertical=${this.vertical}
        .label=${this.label}
        .icon=${this.icon}
      >
        <slot @slotchange=${this.onSlotChange}></slot>
      </bim-input>
    `;
  }
};
Ni.styles = C`
    :host {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
      --bim-input--g: 0;
      --bim-option--jc: center;
      flex: 1;
      display: block;
    }

    ::slotted(bim-option) {
      border-radius: 0;
    }

    ::slotted(bim-option[checked]) {
      --bim-label--c: var(--bim-ui_main-contrast);
      background-color: var(--bim-ui_main-base);
    }
  `;
var mt = Ni;
ge([
  h({ type: String, reflect: true })
], mt.prototype, "name");
ge([
  h({ type: String, reflect: true })
], mt.prototype, "icon");
ge([
  h({ type: String, reflect: true })
], mt.prototype, "label");
ge([
  h({ type: Boolean, reflect: true })
], mt.prototype, "vertical");
ge([
  Ft()
], mt.prototype, "_value");
var vl = () => m`
    <style>
      div {
        display: flex;
        gap: 0.375rem;
        border-radius: 0.25rem;
        min-height: 1.25rem;
      }

      [data-type="row"] {
        background-color: var(--bim-ui_bg-contrast-10);
        animation: row-loading 1s linear infinite alternate;
        padding: 0.5rem;
      }

      [data-type="cell"] {
        background-color: var(--bim-ui_bg-contrast-20);
        flex: 0.25;
      }

      @keyframes row-loading {
        0% {
          background-color: var(--bim-ui_bg-contrast-10);
        }
        100% {
          background-color: var(--bim-ui_bg-contrast-20);
        }
      }
    </style>
    <div style="display: flex; flex-direction: column;">
      <div data-type="row" style="gap: 2rem">
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 2"></div>
        <div data-type="cell" style="flex: 1"></div>
        <div data-type="cell" style="flex: 0.5"></div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
      </div>
      <div style="display: flex;">
        <div data-type="row" style="flex: 1">
          <div data-type="cell"></div>
        </div>
        <div data-type="row" style="flex: 2">
          <div data-type="cell" style="flex: 0.5"></div>
        </div>
        <div data-type="row" style="flex: 1">
          <div data-type="cell" style="flex: 0.75"></div>
        </div>
        <div data-type="row" style="flex: 0.5">
          <div data-type="cell" style="flex: 0.7s5"></div>
        </div>
      </div>
    </div>
  `;
var yl = () => m`
    <style>
      .loader {
        grid-area: Processing;
        position: relative;
        padding: 0.125rem;
      }
      .loader:before {
        content: "";
        position: absolute;
      }
      .loader .loaderBar {
        position: absolute;
        top: 0;
        right: 100%;
        bottom: 0;
        left: 0;
        background: var(--bim-ui_main-base);
        /* width: 25%; */
        width: 0;
        animation: borealisBar 2s linear infinite;
      }

      @keyframes borealisBar {
        0% {
          left: 0%;
          right: 100%;
          width: 0%;
        }
        10% {
          left: 0%;
          right: 75%;
          width: 25%;
        }
        90% {
          right: 0%;
          left: 75%;
          width: 25%;
        }
        100% {
          left: 100%;
          right: 0%;
          width: 0%;
        }
      }
    </style>
    <div class="loader">
      <div class="loaderBar"></div>
    </div>
  `;
var _l = Object.defineProperty;
var xl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && _l(t, e, n), n;
};
var Di = class Di2 extends w {
  constructor() {
    super(...arguments), this.column = "", this.columnIndex = 0, this.rowData = {};
  }
  get data() {
    return this.column ? this.rowData[this.column] : null;
  }
  render() {
    return m`
      <style>
        :host {
          grid-area: ${this.column ?? "unset"};
        }
      </style>
      <slot></slot>
    `;
  }
};
Di.styles = C`
    :host {
      padding: 0.375rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    :host([data-column-index="0"]:not([data-no-indentation])) {
      justify-content: normal;
    }

    :host([data-column-index="0"]:not([data-cell-header]))
      ::slotted(bim-label) {
      text-align: left;
    }

    ::slotted(*) {
      --bim-input--bgc: transparent;
      --bim-input--olc: var(--bim-ui_bg-contrast-20);
      --bim-input--olw: 1px;
    }

    ::slotted(bim-input) {
      --bim-input--olw: 0;
    }

    ::slotted(bim-label) {
      white-space: normal;
      text-align: center;
    }
  `;
var Te = Di;
xl([
  h({ type: String, reflect: true })
], Te.prototype, "column");
var wl = Object.defineProperty;
var $l = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && wl(t, e, n), n;
};
var Fi = class Fi2 extends w {
  constructor() {
    super(...arguments), this._groups = [], this.data = [], this.table = this.closest("bim-table");
  }
  toggleGroups(t, e = false) {
    for (const s of this._groups)
      s.childrenHidden = typeof t > "u" ? !s.childrenHidden : !t, e && s.toggleChildren(t, e);
  }
  render() {
    return this._groups = [], m`
      <slot></slot>
      ${this.data.map((t) => {
      const e = document.createElement(
        "bim-table-group"
      );
      return this._groups.push(e), e.table = this.table, e.data = t, e;
    })}
    `;
  }
};
Fi.styles = C`
    :host {
      --bim-button--bgc: transparent;
      position: relative;
      grid-area: Children;
    }

    :host([hidden]) {
      display: none;
    }

    ::slotted(.branch.branch-vertical) {
      top: 0;
      bottom: 1.125rem;
    }
  `;
var Le = Fi;
$l([
  h({ type: Array, attribute: false })
], Le.prototype, "data");
var Cl = Object.defineProperty;
var El = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Cl(t, e, n), n;
};
var Vi = class Vi2 extends w {
  constructor() {
    super(...arguments), this.data = { data: {} }, this.childrenHidden = true, this.table = this.closest("bim-table");
  }
  connectedCallback() {
    super.connectedCallback(), this.table && this.table.expanded ? this.childrenHidden = false : this.childrenHidden = true;
  }
  toggleChildren(t, e = false) {
    this._children && (this.childrenHidden = typeof t > "u" ? !this.childrenHidden : !t, e && this._children.toggleGroups(t, e));
  }
  render() {
    if (!this.table)
      throw new Error("TableGroup: parent table wasn't found!");
    const t = this.table.getGroupIndentation(this.data) ?? 0, e = m`
      ${this.table.noIndentation ? null : m`
            <style>
              .branch-vertical {
                left: ${t + (this.table.selectableRows ? 1.9375 : 0.5625)}rem;
              }
            </style>
            <div class="branch branch-vertical"></div>
          `}
    `, s = document.createDocumentFragment();
    jt(e, s);
    let n = null;
    this.table.noIndentation || (n = document.createElement("div"), n.classList.add("branch", "branch-horizontal"), n.style.left = `${t - 1 + (this.table.selectableRows ? 2.05 : 0.5625)}rem`);
    let r = null;
    if (!this.table.noIndentation) {
      const l = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      l.setAttribute("height", "9.5"), l.setAttribute("width", "7.5"), l.setAttribute("viewBox", "0 0 4.6666672 7.3333333");
      const c = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      c.setAttribute(
        "d",
        "m 1.7470835,6.9583848 2.5899999,-2.59 c 0.39,-0.39 0.39,-1.02 0,-1.41 L 1.7470835,0.36838483 c -0.63,-0.62000003 -1.71000005,-0.18 -1.71000005,0.70999997 v 5.17 c 0,0.9 1.08000005,1.34 1.71000005,0.71 z"
      ), l.append(c);
      const u = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      u.setAttribute("height", "6.5"), u.setAttribute("width", "9.5"), u.setAttribute("viewBox", "0 0 5.9111118 5.0175439");
      const d = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      d.setAttribute(
        "d",
        "M -0.33616196,1.922522 2.253838,4.5125219 c 0.39,0.39 1.02,0.39 1.41,0 L 6.2538379,1.922522 c 0.6200001,-0.63 0.18,-1.71000007 -0.7099999,-1.71000007 H 0.37383804 c -0.89999997,0 -1.33999997,1.08000007 -0.71,1.71000007 z"
      ), u.append(d), r = document.createElement("div"), r.addEventListener("click", (f) => {
        f.stopPropagation(), this.toggleChildren();
      }), r.classList.add("caret"), r.style.left = `${(this.table.selectableRows ? 1.5 : 0.125) + t}rem`, this.childrenHidden ? r.append(l) : r.append(u);
    }
    const o = document.createElement("bim-table-row");
    this.data.children && !this.childrenHidden && o.append(s), o.table = this.table, o.data = this.data.data, this.table.dispatchEvent(
      new CustomEvent("rowcreated", { detail: { row: o } })
    ), r && this.data.children && o.append(r), t !== 0 && (!this.data.children || this.childrenHidden) && n && o.append(n);
    let a;
    if (this.data.children) {
      a = document.createElement("bim-table-children"), this._children = a, a.table = this.table, a.data = this.data.children;
      const l = document.createDocumentFragment();
      jt(e, l), a.append(l);
    }
    return m`
      <div class="parent">${o} ${this.childrenHidden ? null : a}</div>
    `;
  }
};
Vi.styles = C`
    :host {
      position: relative;
    }

    .parent {
      display: grid;
      grid-template-areas: "Data" "Children";
    }

    .branch {
      position: absolute;
      z-index: 1;
    }

    .branch-vertical {
      border-left: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .branch-horizontal {
      top: 50%;
      width: 1rem;
      border-bottom: 1px dotted var(--bim-ui_bg-contrast-40);
    }

    .caret {
      position: absolute;
      z-index: 2;
      transform: translateY(-50%) rotate(0deg);
      top: 50%;
      display: flex;
      width: 0.95rem;
      height: 0.95rem;
      justify-content: center;
      align-items: center;
      cursor: pointer;
    }

    .caret svg {
      fill: var(--bim-ui_bg-contrast-60);
    }
  `;
var Ie = Vi;
El([
  h({ type: Boolean, attribute: "children-hidden", reflect: true })
], Ie.prototype, "childrenHidden");
var Sl = Object.defineProperty;
var Ut = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Sl(t, e, n), n;
};
var Ui = class Ui2 extends w {
  constructor() {
    super(...arguments), this.selected = false, this.columns = [], this.hiddenColumns = [], this.data = {}, this.isHeader = false, this.table = this.closest("bim-table"), this.onTableColumnsChange = () => {
      this.table && (this.columns = this.table.columns);
    }, this.onTableColumnsHidden = () => {
      this.table && (this.hiddenColumns = this.table.hiddenColumns);
    }, this._observer = new IntersectionObserver(
      (t) => {
        this._intersecting = t[0].isIntersecting;
      },
      { rootMargin: "36px" }
    );
  }
  get _columnNames() {
    return this.columns.filter(
      (s) => !this.hiddenColumns.includes(s.name)
    ).map((s) => s.name);
  }
  get _columnWidths() {
    return this.columns.filter(
      (s) => !this.hiddenColumns.includes(s.name)
    ).map((s) => s.width);
  }
  get _isSelected() {
    var t;
    return (t = this.table) == null ? void 0 : t.selection.has(this.data);
  }
  onSelectionChange(t) {
    if (!this.table)
      return;
    const e = t.target;
    this.selected = e.value, e.value ? (this.table.selection.add(this.data), this.table.dispatchEvent(
      new CustomEvent("rowselected", {
        detail: {
          data: this.data
        }
      })
    )) : (this.table.selection.delete(this.data), this.table.dispatchEvent(
      new CustomEvent("rowdeselected", {
        detail: {
          data: this.data
        }
      })
    ));
  }
  connectedCallback() {
    super.connectedCallback(), this._observer.observe(this), this.table && (this.columns = this.table.columns, this.hiddenColumns = this.table.hiddenColumns, this.table.addEventListener("columnschange", this.onTableColumnsChange), this.table.addEventListener("columnshidden", this.onTableColumnsHidden), this.toggleAttribute("selected", this._isSelected));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this._observer.unobserve(this), this.table && (this.columns = [], this.hiddenColumns = [], this.table.removeEventListener("columnschange", this.onTableColumnsChange), this.table.removeEventListener("columnshidden", this.onTableColumnsHidden), this.toggleAttribute("selected", false));
  }
  compute() {
    if (!this.table)
      throw new Error("TableRow: parent table wasn't found!");
    const t = this.table.getRowIndentation(this.data) ?? 0, e = this.isHeader ? this.data : this.table.applyDataTransform(this.data) ?? this.data, s = [];
    for (const n in e) {
      if (this.hiddenColumns.includes(n))
        continue;
      const r = e[n];
      let o;
      if (typeof r == "string" || typeof r == "boolean" || typeof r == "number" ? (o = document.createElement("bim-label"), o.textContent = String(r)) : r instanceof HTMLElement ? o = r : (o = document.createDocumentFragment(), jt(r, o)), !o)
        continue;
      const a = document.createElement("bim-table-cell");
      a.append(o), a.column = n, this._columnNames.indexOf(n) === 0 && !this.isHeader && (a.style.marginLeft = `${(this.table.noIndentation ? 0 : t) + 0.75}rem`);
      const l = this._columnNames.indexOf(n);
      a.setAttribute("data-column-index", String(l)), a.toggleAttribute(
        "data-no-indentation",
        l === 0 && this.table.noIndentation
      ), a.toggleAttribute("data-cell-header", this.isHeader), a.rowData = this.data, this.table.dispatchEvent(
        new CustomEvent("cellcreated", {
          detail: { cell: a }
        })
      ), s.push(a);
    }
    return this.style.gridTemplateAreas = `"${this.table.selectableRows ? "Selection" : ""} ${this._columnNames.join(" ")}"`, this.style.gridTemplateColumns = `${this.table.selectableRows ? "1.6rem" : ""} ${this._columnWidths.join(" ")}`, m`
      ${!this.isHeader && this.table.selectableRows ? m`<bim-checkbox
            @change=${this.onSelectionChange}
            .checked=${this._isSelected}
            style="align-self: center; justify-self: center"
          ></bim-checkbox>` : null}
      ${s}
      <slot></slot>
    `;
  }
  render() {
    return m`${this._intersecting ? this.compute() : m``}`;
  }
};
Ui.styles = C`
    :host {
      position: relative;
      grid-area: Data;
      display: grid;
      min-height: 2.25rem;
      transition: all 0.15s;
    }

    ::slotted(.branch.branch-vertical) {
      top: 50%;
      bottom: 0;
    }

    :host([selected]) {
      background-color: color-mix(
        in lab,
        var(--bim-ui_bg-contrast-20) 30%,
        var(--bim-ui_main-base) 10%
      );
    }
  `;
var tt = Ui;
Ut([
  h({ type: Boolean, reflect: true })
], tt.prototype, "selected");
Ut([
  h({ attribute: false })
], tt.prototype, "columns");
Ut([
  h({ attribute: false })
], tt.prototype, "hiddenColumns");
Ut([
  h({ attribute: false })
], tt.prototype, "data");
Ut([
  h({ type: Boolean, attribute: "is-header", reflect: true })
], tt.prototype, "isHeader");
Ut([
  Ft()
], tt.prototype, "_intersecting");
var Al = Object.defineProperty;
var Ol = Object.getOwnPropertyDescriptor;
var q = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Ol(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Al(t, e, n), n;
};
var qi = class qi2 extends w {
  constructor() {
    super(...arguments), this._columnsChange = new Event("columnschange"), this._filteredData = [], this.headersHidden = false, this.minColWidth = "4rem", this._columns = [], this._textDelimiters = {
      comma: ",",
      tab: "	"
    }, this._queryString = null, this._data = [], this.expanded = false, this.preserveStructureOnFilter = false, this.indentationInText = false, this.dataTransform = {}, this.selectableRows = false, this.selection = /* @__PURE__ */ new Set(), this.noIndentation = false, this.loading = false, this._errorLoading = false, this._onColumnsHidden = new Event("columnshidden"), this._hiddenColumns = [], this.loadingErrorElement = null, this._stringFilterFunction = (t, e) => Object.values(e.data).some((n) => String(n).toLowerCase().includes(t.toLowerCase())), this._queryFilterFunction = (t, e) => {
      let s = false;
      const n = fi(t) ?? [];
      for (const r of n) {
        if ("queries" in r) {
          s = false;
          break;
        }
        const { condition: o, value: a } = r;
        let { key: l } = r;
        if (l.startsWith("[") && l.endsWith("]")) {
          const c = l.replace("[", "").replace("]", "");
          l = c, s = Object.keys(e.data).filter((f) => f.includes(c)).map(
            (f) => Rn(e.data[f], o, a)
          ).some((f) => f);
        } else
          s = Rn(e.data[l], o, a);
        if (!s)
          break;
      }
      return s;
    };
  }
  set columns(t) {
    const e = [];
    for (const s of t) {
      const n = typeof s == "string" ? { name: s, width: `minmax(${this.minColWidth}, 1fr)` } : s;
      e.push(n);
    }
    this._columns = e, this.computeMissingColumns(this.data), this.dispatchEvent(this._columnsChange);
  }
  get columns() {
    return this._columns;
  }
  get _headerRowData() {
    const t = {};
    for (const e of this.columns)
      if (typeof e == "string")
        t[e] = e;
      else {
        const { name: s } = e;
        t[s] = s;
      }
    return t;
  }
  /**
   * Getter for the `value` property.
   * Returns the filtered data if a search string is provided, otherwise returns the original data.
   *
   * @example
   * ```typescript
   * const tableValue = table.value;
   * console.log(tableValue); // Output: The filtered or original data.
   * ```
   */
  get value() {
    return this._filteredData;
  }
  /**
   * Sets the search string for filtering the table data.
   * This property allows you to filter the table data based on a search string.
   * If a search string is provided, the table will only display rows that match the search criteria.
   * The search criteria can be a simple string or a complex query.
   * If a simple string is provided, the table will filter rows based on the string's presence in any column.
   * If a complex query is provided, the table will filter rows based on the query's conditions and values.
   *
   * @example Simple Query
   * ```typescript
   * table.queryString = "example";
   * ```
   *
   * @example Complex Query
   * ```typescript
   * table.queryString = "column1="Jhon Doe" & column2=20";
   * ```
   */
  set queryString(t) {
    this.toggleAttribute("data-processing", true), this._queryString = t && t.trim() !== "" ? t.trim() : null, this.updateFilteredData(), this.toggleAttribute("data-processing", false);
  }
  get queryString() {
    return this._queryString;
  }
  set data(t) {
    this._data = t, this.updateFilteredData(), this.computeMissingColumns(t) && (this.columns = this._columns);
  }
  get data() {
    return this._data;
  }
  get dataAsync() {
    return new Promise((t) => {
      setTimeout(() => {
        t(this.data);
      });
    });
  }
  set hiddenColumns(t) {
    this._hiddenColumns = t, setTimeout(() => {
      this.dispatchEvent(this._onColumnsHidden);
    });
  }
  get hiddenColumns() {
    return this._hiddenColumns;
  }
  updateFilteredData() {
    this.queryString ? (fi(this.queryString) ? (this.filterFunction = this._queryFilterFunction, this._filteredData = this.filter(this.queryString)) : (this.filterFunction = this._stringFilterFunction, this._filteredData = this.filter(this.queryString)), this.preserveStructureOnFilter && (this._expandedBeforeFilter === void 0 && (this._expandedBeforeFilter = this.expanded), this.expanded = true)) : (this.preserveStructureOnFilter && this._expandedBeforeFilter !== void 0 && (this.expanded = this._expandedBeforeFilter, this._expandedBeforeFilter = void 0), this._filteredData = this.data);
  }
  computeMissingColumns(t) {
    let e = false;
    for (const s of t) {
      const { children: n, data: r } = s;
      for (const o in r)
        this._columns.map((l) => typeof l == "string" ? l : l.name).includes(o) || (this._columns.push({
          name: o,
          width: `minmax(${this.minColWidth}, 1fr)`
        }), e = true);
      if (n) {
        const o = this.computeMissingColumns(n);
        o && !e && (e = o);
      }
    }
    return e;
  }
  generateText(t = "comma", e = this.value, s = "", n = true) {
    const r = this._textDelimiters[t];
    let o = "";
    const a = this.columns.map((l) => l.name);
    if (n) {
      this.indentationInText && (o += `Indentation${r}`);
      const l = `${a.join(r)}
`;
      o += l;
    }
    for (const [l, c] of e.entries()) {
      const { data: u, children: d } = c, f = this.indentationInText ? `${s}${l + 1}${r}` : "", p = a.map((v) => u[v] ?? ""), b = `${f}${p.join(r)}
`;
      o += b, d && (o += this.generateText(
        t,
        c.children,
        `${s}${l + 1}.`,
        false
      ));
    }
    return o;
  }
  /**
   * A getter function that generates a CSV (Comma Separated Values) representation of the table data.
   *
   * @returns A string containing the CSV representation of the table data.
   *
   * @example
   * ```typescript
   * const csvData = table.csv;
   * console.log(csvData); // Output: "Column 1,Column 2\nValue 1,Value 2\nValue 3,Value 4"
   * ```
   */
  get csv() {
    return this.generateText("comma");
  }
  /**
   * A getter function that generates a Tab Separated Values (TSV) representation of the table data.
   *
   * @returns A string containing the TSV representation of the table data.
   *
   * @example
   * ```typescript
   * const tsvData = table.tsv;
   * console.log(tsvData); // Output: "Column 1\tColumn 2\nValue 1\tValue 2\nValue 3\tValue 4"
   * ```
   */
  get tsv() {
    return this.generateText("tab");
  }
  applyDataTransform(t) {
    const e = {};
    for (const s of Object.keys(this.dataTransform)) {
      const n = this.columns.find((r) => r.name === s);
      n && n.forceDataTransform && (s in t || (t[s] = ""));
    }
    for (const s in t) {
      const n = this.dataTransform[s];
      n ? e[s] = n(t[s], t) : e[s] = t[s];
    }
    return e;
  }
  /**
   * The `downloadData` method is used to download the table data in different formats.
   *
   * @param fileName - The name of the downloaded file. Default is "BIM Table Data".
   * @param format - The format of the downloaded file. Can be "json", "tsv", or "csv". Default is "json".
   *
   * @returns - This method does not return any value.
   *
   * @example
   * ```typescript
   * table.downloadData("MyTableData", "tsv");
   * ```
   */
  downloadData(t = "BIM Table Data", e = "json") {
    let s = null;
    if (e === "json" && (s = new File(
      [JSON.stringify(this.value, void 0, 2)],
      `${t}.json`
    )), e === "csv" && (s = new File([this.csv], `${t}.csv`)), e === "tsv" && (s = new File([this.tsv], `${t}.tsv`)), !s)
      return;
    const n = document.createElement("a");
    n.href = URL.createObjectURL(s), n.download = s.name, n.click(), URL.revokeObjectURL(n.href);
  }
  getRowIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n.data === t)
        return s;
      if (n.children) {
        const r = this.getRowIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  getGroupIndentation(t, e = this.value, s = 0) {
    for (const n of e) {
      if (n === t)
        return s;
      if (n.children) {
        const r = this.getGroupIndentation(
          t,
          n.children,
          s + 1
        );
        if (r !== null)
          return r;
      }
    }
    return null;
  }
  connectedCallback() {
    super.connectedCallback(), this.dispatchEvent(new Event("connected"));
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.dispatchEvent(new Event("disconnected"));
  }
  /**
   * Asynchronously loads data into the table based on Table.loadFunction.
   * If the data is already available, just set it in Table.data.
   *
   * @param force - A boolean indicating whether to force loading even if the table already has data.
   *
   * @returns - A promise that resolves to a boolean indicating whether the data loading was successful.
   * If the promise resolves to `true`, the data loading was successful.
   * If the promise resolves to `false`, the data loading was not successful.
   *
   * @remarks - If the table already has data and `force` is `false`, the function resolves to `false` without making any changes.
   * If the table already has data and `force` is `true`, the existing data is discarded before loading the new data.
   * If an error occurs during data loading, the function sets the `errorLoadingMessage` property with the error message and resolves to `false`.
   */
  async loadData(t = false) {
    if (this._filteredData.length !== 0 && !t || !this.loadFunction)
      return false;
    this.loading = true;
    try {
      const e = await this.loadFunction();
      return this.data = e, this.loading = false, this._errorLoading = false, true;
    } catch (e) {
      return this.loading = false, this._filteredData.length !== 0 || (e instanceof Error && this.loadingErrorElement && e.message.trim() !== "" && (this.loadingErrorElement.textContent = e.message), this._errorLoading = true), false;
    }
  }
  filter(t, e = this.filterFunction ?? this._stringFilterFunction, s = this.data) {
    const n = [];
    for (const r of s)
      if (e(t, r)) {
        if (this.preserveStructureOnFilter) {
          const a = { data: r.data };
          if (r.children) {
            const l = this.filter(
              t,
              e,
              r.children
            );
            l.length && (a.children = l);
          }
          n.push(a);
        } else if (n.push({ data: r.data }), r.children) {
          const a = this.filter(
            t,
            e,
            r.children
          );
          n.push(...a);
        }
      } else if (r.children) {
        const a = this.filter(
          t,
          e,
          r.children
        );
        this.preserveStructureOnFilter && a.length ? n.push({
          data: r.data,
          children: a
        }) : n.push(...a);
      }
    return n;
  }
  get _missingDataElement() {
    return this.querySelector("[slot='missing-data']");
  }
  render() {
    if (this.loading)
      return vl();
    if (this._errorLoading)
      return m`<slot name="error-loading"></slot>`;
    if (this._filteredData.length === 0 && this._missingDataElement)
      return m`<slot name="missing-data"></slot>`;
    const t = document.createElement("bim-table-row");
    t.table = this, t.isHeader = true, t.data = this._headerRowData, t.style.gridArea = "Header", t.style.position = "sticky", t.style.top = "0", t.style.zIndex = "5";
    const e = document.createElement("bim-table-children");
    return e.table = this, e.data = this.value, e.style.gridArea = "Body", e.style.backgroundColor = "transparent", m`
      <div class="parent">
        ${this.headersHidden ? null : t} ${yl()}
        <div style="overflow-x: hidden; grid-area: Body">${e}</div>
      </div>
    `;
  }
};
qi.styles = [
  vt.scrollbar,
  C`
      :host {
        position: relative;
        overflow: auto;
        display: block;
        pointer-events: auto;
      }

      :host(:not([data-processing])) .loader {
        display: none;
      }

      .parent {
        display: grid;
        grid-template:
          "Header" auto
          "Processing" auto
          "Body" 1fr
          "Footer" auto;
        overflow: auto;
        height: 100%;
      }

      .parent > bim-table-row[is-header] {
        color: var(--bim-table_header--c, var(--bim-ui_bg-contrast-100));
        background-color: var(
          --bim-table_header--bgc,
          var(--bim-ui_bg-contrast-20)
        );
      }

      .controls {
        display: flex;
        gap: 0.375rem;
        flex-wrap: wrap;
        margin-bottom: 0.5rem;
      }
    `
];
var M = qi;
q([
  Ft()
], M.prototype, "_filteredData", 2);
q([
  h({
    type: Boolean,
    attribute: "headers-hidden",
    reflect: true
  })
], M.prototype, "headersHidden", 2);
q([
  h({ type: String, attribute: "min-col-width", reflect: true })
], M.prototype, "minColWidth", 2);
q([
  h({ type: Array, attribute: false })
], M.prototype, "columns", 1);
q([
  h({ type: Array, attribute: false })
], M.prototype, "data", 1);
q([
  h({ type: Boolean, reflect: true })
], M.prototype, "expanded", 2);
q([
  h({ type: Boolean, reflect: true, attribute: "selectable-rows" })
], M.prototype, "selectableRows", 2);
q([
  h({ attribute: false })
], M.prototype, "selection", 2);
q([
  h({ type: Boolean, attribute: "no-indentation", reflect: true })
], M.prototype, "noIndentation", 2);
q([
  h({ type: Boolean, reflect: true })
], M.prototype, "loading", 2);
q([
  Ft()
], M.prototype, "_errorLoading", 2);
var kl = Object.defineProperty;
var Pl = Object.getOwnPropertyDescriptor;
var Ue = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Pl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && kl(t, e, n), n;
};
var Wi = class Wi2 extends w {
  constructor() {
    super(...arguments), this._defaultName = "__unnamed__", this.name = this._defaultName, this._hidden = false;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  connectedCallback() {
    super.connectedCallback();
    const { parentElement: t } = this;
    if (t && this.name === this._defaultName) {
      const e = [...t.children].indexOf(this);
      this.name = `${this._defaultName}${e}`;
    }
  }
  render() {
    return m` <slot></slot> `;
  }
};
Wi.styles = C`
    :host {
      display: block;
      height: 100%;
    }

    :host([hidden]) {
      display: none;
    }
  `;
var R = Wi;
Ue([
  h({ type: String, reflect: true })
], R.prototype, "name", 2);
Ue([
  h({ type: String, reflect: true })
], R.prototype, "label", 2);
Ue([
  h({ type: String, reflect: true })
], R.prototype, "icon", 2);
Ue([
  h({ type: Boolean, reflect: true })
], R.prototype, "hidden", 1);
var Tl = Object.defineProperty;
var Ll = Object.getOwnPropertyDescriptor;
var qt = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Ll(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Tl(t, e, n), n;
};
var Qi = class Qi2 extends w {
  constructor() {
    super(...arguments), this._switchers = [], this.bottom = false, this.switchersHidden = false, this.floating = false, this.switchersFull = false, this.onTabHiddenChange = (t) => {
      const e = t.target;
      e instanceof R && !e.hidden && (e.removeEventListener("hiddenchange", this.onTabHiddenChange), this.tab = e.name, e.addEventListener("hiddenchange", this.onTabHiddenChange));
    };
  }
  set tab(t) {
    this._tab = t;
    const e = [...this.children], s = e.find(
      (n) => n instanceof R && n.name === t
    );
    for (const n of e) {
      if (!(n instanceof R))
        continue;
      n.hidden = s !== n;
      const r = this.getTabSwitcher(n.name);
      r && r.toggleAttribute("data-active", !n.hidden);
    }
  }
  get tab() {
    return this._tab;
  }
  getTabSwitcher(t) {
    return this._switchers.find(
      (s) => s.getAttribute("data-name") === t
    );
  }
  createSwitchers() {
    this._switchers = [];
    for (const t of this.children) {
      if (!(t instanceof R))
        continue;
      const e = document.createElement("div");
      e.addEventListener("click", () => {
        this.tab === t.name ? this.toggleAttribute("tab", false) : this.tab = t.name;
      }), e.setAttribute("data-name", t.name), e.className = "switcher";
      const s = document.createElement("bim-label");
      s.textContent = t.label ?? "", s.icon = t.icon, e.append(s), this._switchers.push(e);
    }
  }
  onSlotChange(t) {
    this.createSwitchers();
    const e = t.target.assignedElements(), s = e.find((n) => n instanceof R ? this.tab ? n.name === this.tab : !n.hidden : false);
    s && s instanceof R && (this.tab = s.name);
    for (const n of e) {
      if (!(n instanceof R)) {
        n.remove();
        continue;
      }
      n.removeEventListener("hiddenchange", this.onTabHiddenChange), s !== n && (n.hidden = true), n.addEventListener("hiddenchange", this.onTabHiddenChange);
    }
  }
  render() {
    return m`
      <div class="parent">
        <div class="switchers">${this._switchers}</div>
        <div class="content">
          <slot @slotchange=${this.onSlotChange}></slot>
        </div>
      </div>
    `;
  }
};
Qi.styles = [
  vt.scrollbar,
  C`
      * {
        box-sizing: border-box;
      }

      :host {
        background-color: var(--bim-ui_bg-base);
        display: block;
        overflow: auto;
      }

      .parent {
        display: grid;
        grid-template: "switchers" auto "content" 1fr;
        height: 100%;
      }

      :host([bottom]) .parent {
        grid-template: "content" 1fr "switchers" auto;
      }

      .switchers {
        display: flex;
        height: 2.25rem;
        font-weight: 600;
        grid-area: switchers;
      }

      .switcher {
        --bim-label--c: var(--bim-ui_bg-contrast-80);
        background-color: var(--bim-ui_bg-base);
        cursor: pointer;
        pointer-events: auto;
        padding: 0rem 0.75rem;
        display: flex;
        justify-content: center;
        transition: all 0.15s;
      }

      :host([switchers-full]) .switcher {
        flex: 1;
      }

      .switcher:hover,
      .switcher[data-active] {
        --bim-label--c: var(--bim-ui_main-contrast);
        background-color: var(--bim-ui_main-base);
      }

      .switchers bim-label {
        pointer-events: none;
      }

      :host([switchers-hidden]) .switchers {
        display: none;
      }

      .content {
        grid-area: content;
        overflow: auto;
      }

      :host(:not([bottom])) .content {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([bottom]) .content {
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host(:not([tab])) .content {
        display: none;
      }

      :host([floating]) {
        background-color: transparent;
      }

      :host([floating]) .switchers {
        justify-self: center;
        overflow: auto;
      }

      :host([floating]:not([bottom])) .switchers {
        border-radius: var(--bim-ui_size-2xs) var(--bim-ui_size-2xs) 0 0;
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]) .switchers {
        border-radius: 0 0 var(--bim-ui_size-2xs) var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
        border-left: 1px solid var(--bim-ui_bg-contrast-20);
        border-right: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]:not([tab])) .switchers {
        border-radius: var(--bim-ui_size-2xs);
        border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating][bottom]:not([tab])) .switchers {
        border-top: 1px solid var(--bim-ui_bg-contrast-20);
      }

      :host([floating]) .content {
        border: 1px solid var(--bim-ui_bg-contrast-20);
        border-radius: var(--bim-ui_size-2xs);
        background-color: var(--bim-ui_bg-base);
      }
    `
];
var et = Qi;
qt([
  Ft()
], et.prototype, "_switchers", 2);
qt([
  h({ type: Boolean, reflect: true })
], et.prototype, "bottom", 2);
qt([
  h({ type: Boolean, attribute: "switchers-hidden", reflect: true })
], et.prototype, "switchersHidden", 2);
qt([
  h({ type: Boolean, reflect: true })
], et.prototype, "floating", 2);
qt([
  h({ type: String, reflect: true })
], et.prototype, "tab", 1);
qt([
  h({ type: Boolean, attribute: "switchers-full", reflect: true })
], et.prototype, "switchersFull", 2);
var zn = (i) => i ?? k;
var Il = Object.defineProperty;
var Rl = Object.getOwnPropertyDescriptor;
var it = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Rl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Il(t, e, n), n;
};
var Yi = class Yi2 extends w {
  constructor() {
    super(...arguments), this._inputTypes = [
      "date",
      "datetime-local",
      "email",
      "month",
      "password",
      "search",
      "tel",
      "text",
      "time",
      "url",
      "week",
      "area"
    ], this.value = "", this.vertical = false, this._type = "text", this.onValueChange = new Event("input");
  }
  set type(t) {
    this._inputTypes.includes(t) && (this._type = t);
  }
  get type() {
    return this._type;
  }
  /**
   * Gets the query value derived from the current input value.
   * The `getQuery` function is assumed to be a utility function that takes a string as input
   * and returns a processed query value based on the input.
   *
   * @returns The processed query value derived from the current input value.
   *
   * @example
   * ```typescript
   * const textInput = new TextInput();
   * textInput.value = "Key?Value";
   * console.log(textInput.query);
   * ```
   */
  get query() {
    return fi(this.value);
  }
  onInputChange(t) {
    t.stopPropagation();
    const e = t.target;
    clearTimeout(this._debounceTimeoutID), this._debounceTimeoutID = setTimeout(() => {
      this.value = e.value, this.dispatchEvent(this.onValueChange);
    }, this.debounce);
  }
  focus() {
    setTimeout(() => {
      var e;
      const t = (e = this.shadowRoot) == null ? void 0 : e.querySelector("input");
      t == null || t.focus();
    });
  }
  render() {
    return m`
      <bim-input
        .name=${this.name}
        .icon=${this.icon}
        .label=${this.label}
        .vertical=${this.vertical}
      >
        ${this.type === "area" ? m` <textarea
              aria-label=${this.label || this.name || "Text Input"}
              .value=${this.value}
              .rows=${this.rows ?? 5}
              placeholder=${zn(this.placeholder)}
              @input=${this.onInputChange}
            ></textarea>` : m` <input
              aria-label=${this.label || this.name || "Text Input"}
              .type=${this.type}
              .value=${this.value}
              placeholder=${zn(this.placeholder)}
              @input=${this.onInputChange}
            />`}
      </bim-input>
    `;
  }
};
Yi.styles = [
  vt.scrollbar,
  C`
      :host {
        --bim-input--bgc: var(--bim-ui_bg-contrast-20);
        flex: 1;
        display: block;
      }

      input,
      textarea {
        font-family: inherit;
        background-color: transparent;
        border: none;
        width: 100%;
        padding: var(--bim-ui_size-3xs);
        color: var(--bim-text-input--c, var(--bim-ui_bg-contrast-100));
      }

      input {
        outline: none;
        height: 100%;
        padding: 0 var(--bim-ui_size-3xs); /* Override padding */
        border-radius: var(--bim-text-input--bdrs, var(--bim-ui_size-4xs));
      }

      textarea {
        line-height: 1.1rem;
        resize: vertical;
      }

      :host(:focus) {
        --bim-input--olc: var(--bim-ui_accent-base);
      }

      /* :host([disabled]) {
      --bim-input--bgc: var(--bim-ui_bg-contrast-20);
    } */
    `
];
var H = Yi;
it([
  h({ type: String, reflect: true })
], H.prototype, "icon", 2);
it([
  h({ type: String, reflect: true })
], H.prototype, "label", 2);
it([
  h({ type: String, reflect: true })
], H.prototype, "name", 2);
it([
  h({ type: String, reflect: true })
], H.prototype, "placeholder", 2);
it([
  h({ type: String, reflect: true })
], H.prototype, "value", 2);
it([
  h({ type: Boolean, reflect: true })
], H.prototype, "vertical", 2);
it([
  h({ type: Number, reflect: true })
], H.prototype, "debounce", 2);
it([
  h({ type: Number, reflect: true })
], H.prototype, "rows", 2);
it([
  h({ type: String, reflect: true })
], H.prototype, "type", 1);
var zl = Object.defineProperty;
var Ml = Object.getOwnPropertyDescriptor;
var js = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Ml(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && zl(t, e, n), n;
};
var Gi = class Gi2 extends w {
  constructor() {
    super(...arguments), this.rows = 2, this._vertical = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      this.vertical ? e.setAttribute("label-hidden", "") : e.removeAttribute("label-hidden");
  }
  render() {
    return m`
      <style>
        .parent {
          grid-auto-flow: ${this.vertical ? "row" : "column"};
          grid-template-rows: repeat(${this.rows}, 1fr);
        }
      </style>
      <div class="parent">
        <slot @slotchange=${this.updateChildren}></slot>
      </div>
    `;
  }
};
Gi.styles = C`
    .parent {
      display: grid;
      gap: 0.25rem;
    }

    ::slotted(bim-button[label]:not([vertical])) {
      --bim-button--jc: flex-start;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }
  `;
var Nt = Gi;
js([
  h({ type: Number, reflect: true })
], Nt.prototype, "rows", 2);
js([
  h({ type: Boolean, reflect: true })
], Nt.prototype, "vertical", 1);
var jl = Object.defineProperty;
var Bl = Object.getOwnPropertyDescriptor;
var qe = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Bl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && jl(t, e, n), n;
};
var Ki = class Ki2 extends w {
  constructor() {
    super(...arguments), this._vertical = false, this._labelHidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateChildren();
  }
  get vertical() {
    return this._vertical;
  }
  set labelHidden(t) {
    this._labelHidden = t, this.updateChildren();
  }
  get labelHidden() {
    return this._labelHidden;
  }
  updateChildren() {
    const t = this.children;
    for (const e of t)
      e instanceof Nt && (e.vertical = this.vertical), e.toggleAttribute("label-hidden", this.vertical);
  }
  render() {
    return m`
      <div class="parent">
        <div class="children">
          <slot @slotchange=${this.updateChildren}></slot>
        </div>
        ${!this.labelHidden && (this.label || this.icon) ? m`<bim-label .icon=${this.icon}>${this.label}</bim-label>` : null}
      </div>
    `;
  }
};
Ki.styles = C`
    :host {
      --bim-label--fz: var(--bim-ui_size-xs);
      --bim-label--c: var(--bim-ui_bg-contrast-60);
      display: block;
      flex: 1;
    }

    :host(:not([vertical])) ::slotted(bim-button[vertical]) {
      --bim-icon--fz: var(--bim-ui_size-5xl);
      min-height: 3.75rem;
    }

    ::slotted(bim-button) {
      --bim-label--c: var(--bim-ui_bg-contrast-80);
    }

    .parent {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      align-items: center;
      padding: 0.5rem;
      height: 100%;
      box-sizing: border-box;
      justify-content: space-between;
    }

    :host([vertical]) .parent {
      flex-direction: row-reverse;
    }

    :host([vertical]) .parent > bim-label {
      writing-mode: tb;
    }

    .children {
      display: flex;
      gap: 0.25rem;
    }

    :host([vertical]) .children {
      flex-direction: column;
    }
  `;
var bt = Ki;
qe([
  h({ type: String, reflect: true })
], bt.prototype, "label", 2);
qe([
  h({ type: String, reflect: true })
], bt.prototype, "icon", 2);
qe([
  h({ type: Boolean, reflect: true })
], bt.prototype, "vertical", 1);
qe([
  h({ type: Boolean, attribute: "label-hidden", reflect: true })
], bt.prototype, "labelHidden", 1);
var Hl = Object.defineProperty;
var Nl = Object.getOwnPropertyDescriptor;
var Oi = (i, t, e, s) => {
  for (var n = s > 1 ? void 0 : s ? Nl(t, e) : t, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = (s ? o(t, e, n) : o(n)) || n);
  return s && n && Hl(t, e, n), n;
};
var Xi = class Xi2 extends w {
  constructor() {
    super(...arguments), this.labelsHidden = false, this._vertical = false, this._hidden = false;
  }
  set vertical(t) {
    this._vertical = t, this.updateSections();
  }
  get vertical() {
    return this._vertical;
  }
  set hidden(t) {
    this._hidden = t, this.dispatchEvent(new Event("hiddenchange"));
  }
  get hidden() {
    return this._hidden;
  }
  // private setActivationButton() {
  //   this.activationButton.draggable = Manager.config.draggableToolbars;
  //   this.activationButton.addEventListener(
  //     "click",
  //     () => (this.hidden = !this.hidden),
  //   );
  //   this.activationButton.setAttribute("data-ui-manager-id", this._managerID);
  //   this.activationButton.addEventListener("dragstart", (e) => {
  //     const id = this.getAttribute("data-ui-manager-id");
  //     if (e.dataTransfer && id) {
  //       e.dataTransfer.setData("id", id);
  //       e.dataTransfer.effectAllowed = "move";
  //     }
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       if (container === this.parentElement) continue;
  //       container.dropping = true;
  //     }
  //   });
  //   this.activationButton.addEventListener("dragend", (e) => {
  //     if (e.dataTransfer) e.dataTransfer.clearData();
  //     const containers = document.querySelectorAll("bim-toolbars-container");
  //     for (const container of containers) {
  //       container.dropping = false;
  //     }
  //   });
  // }
  updateSections() {
    const t = this.children;
    for (const e of t)
      e instanceof bt && (e.labelHidden = this.vertical && !di.config.sectionLabelOnVerticalToolbar, e.vertical = this.vertical);
  }
  // firstUpdated() {
  //   this.setAttribute("data-ui-manager-id", this._managerID);
  // }
  render() {
    return m`
      <div class="parent">
        <slot @slotchange=${this.updateSections}></slot>
      </div>
    `;
  }
};
Xi.styles = C`
    :host {
      --bim-button--bgc: transparent;
      background-color: var(--bim-ui_bg-base);
      border-radius: var(--bim-ui_size-2xs);
      display: block;
    }

    :host([hidden]) {
      display: none;
    }

    .parent {
      display: flex;
      width: min-content;
      pointer-events: auto;
    }

    :host([vertical]) .parent {
      flex-direction: column;
    }

    :host([vertical]) {
      width: min-content;
      border-radius: var(--bim-ui_size-2xs);
      border: 1px solid var(--bim-ui_bg-contrast-20);
    }

    ::slotted(bim-toolbar-section:not(:last-child)) {
      border-right: 1px solid var(--bim-ui_bg-contrast-20);
      border-bottom: none;
    }

    :host([vertical]) ::slotted(bim-toolbar-section:not(:last-child)) {
      border-bottom: 1px solid var(--bim-ui_bg-contrast-20);
      border-right: none;
    }
  `;
var Dt = Xi;
Oi([
  h({ type: String, reflect: true })
], Dt.prototype, "icon", 2);
Oi([
  h({ type: Boolean, attribute: "labels-hidden", reflect: true })
], Dt.prototype, "labelsHidden", 2);
Oi([
  h({ type: Boolean, reflect: true })
], Dt.prototype, "vertical", 1);
var Dl = Object.defineProperty;
var Fl = (i, t, e, s) => {
  for (var n = void 0, r = i.length - 1, o; r >= 0; r--)
    (o = i[r]) && (n = o(t, e, n) || n);
  return n && Dl(t, e, n), n;
};
var Ji = class Ji2 extends w {
  constructor() {
    super(), this._onResize = new Event("resize"), new ResizeObserver(() => {
      setTimeout(() => {
        this.dispatchEvent(this._onResize);
      });
    }).observe(this);
  }
  render() {
    return m`
      <div class="parent">
        <slot></slot>
      </div>
    `;
  }
};
Ji.styles = C`
    :host {
      display: grid;
      min-width: 0;
      min-height: 0;
      height: 100%;
    }

    .parent {
      overflow: hidden;
      position: relative;
    }
  `;
var Re = Ji;
Fl([
  h({ type: String, reflect: true })
], Re.prototype, "name");
var Bs = "important";
var Vl = " !" + Bs;
var Wl = cs(class extends us {
  constructor(i) {
    var t;
    if (super(i), i.type !== as.ATTRIBUTE || i.name !== "style" || ((t = i.strings) == null ? void 0 : t.length) > 2)
      throw Error("The `styleMap` directive must be used in the `style` attribute and must be the only part in the attribute.");
  }
  render(i) {
    return Object.keys(i).reduce((t, e) => {
      const s = i[e];
      return s == null ? t : t + `${e = e.includes("-") ? e : e.replace(/(?:^(webkit|moz|ms|o)|)(?=[A-Z])/g, "-$&").toLowerCase()}:${s};`;
    }, "");
  }
  update(i, [t]) {
    const { style: e } = i.element;
    if (this.ft === void 0)
      return this.ft = new Set(Object.keys(t)), this.render(t);
    for (const s of this.ft)
      t[s] == null && (this.ft.delete(s), s.includes("-") ? e.removeProperty(s) : e[s] = null);
    for (const s in t) {
      const n = t[s];
      if (n != null) {
        this.ft.add(s);
        const r = typeof n == "string" && n.endsWith(Vl);
        s.includes("-") || r ? e.setProperty(s, r ? n.slice(0, -11) : n, r ? Bs : "") : e[s] = n;
      }
    }
    return St;
  }
});
export {
  z as Button,
  dt as Checkbox,
  J as ColorInput,
  Rs as Component,
  nl as ContextMenu,
  V as Dropdown,
  le as Grid,
  pi as Icon,
  At as Input,
  ft as Label,
  di as Manager,
  I as NumberInput,
  T as Option,
  Z as Panel,
  pt as PanelSection,
  mt as Selector,
  R as Tab,
  M as Table,
  Te as TableCell,
  Le as TableChildren,
  Ie as TableGroup,
  tt as TableRow,
  et as Tabs,
  H as TextInput,
  Dt as Toolbar,
  Nt as ToolbarGroup,
  bt as ToolbarSection,
  Re as Viewport,
  m as html,
  Ht as ref,
  Wl as styleMap
};
/*! Bundled license information:

@thatopen/ui/dist/index.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
  (**
  * (c) Iconify
  *
  * For the full copyright and license information, please view the license.txt
  * files at https://github.com/iconify/iconify
  *
  * Licensed under MIT.
  *
  * @license MIT
  * @version 2.0.0
  *)
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@thatopen_ui.js.map
